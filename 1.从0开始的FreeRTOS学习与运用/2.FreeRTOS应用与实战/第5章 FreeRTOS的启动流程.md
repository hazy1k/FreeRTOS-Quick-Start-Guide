# 第五章 FreeRTOS的启动流程

在目前的 RTOS 中，主要有两种比较流行的启动方式，暂时还没有看到第三种，接下来将通过伪代码的方式来讲解下这两种启动方式的区别，然后再具体分析下 FreeRTOS的启动流程。

## 1. 硬件初始化，RTOS系统初始化

第一种我称之为万事俱备， 只欠东风法。这种方法是在 main 函数中将硬件初始化， RTOS 系统初始化，所有任务的创建这些都弄好，这个我称之为万事都已经准备好。最后只欠一道东风，即启动 RTOS 的调度器，开始多任务的调度，具体的伪代码实现见代码：

```c
int main (void)
{
    // 硬件初始化 
    HardWare_Init(); 
    // RTOS 系统初始化 
    RTOS_Init(); 
    // 创建任务 1，但任务 1 不会执行，因为调度器还没有开启 
    RTOS_TaskCreate(Task1);
    // 创建任务 2，但任务 2 不会执行，因为调度器还没有开启 
    RTOS_TaskCreate(Task2);
    // 启动 RTOS，开始调度 
    RTOS_Start(); 
}
void Task1(void *arg) 
{
    while (1)
    {
        // 任务实体，必须有阻塞的情况出现 
    }
}
void Task1(void *arg)
{
    while (1)
    {
    // 任务实体，必须有阻塞的情况出现 
    }
}
```

- 硬件初始化。硬件初始化这一步还属于裸机的范畴，我们可以把需要使用到的硬件都初始化好而且测试好，确保无误。

- RTOS 系统初始化。比如 RTOS 里面的全局变量的初始化，空闲任务的创建等。不同的 RTOS，它们的初始化有细微的差别。

- 创建各种任务。这里把所有要用到的任务都创建好，但还不会进入调度，因为这个时候 RTOS 的调度器还没有开启。

- 启动 RTOS 调度器，开始任务调度。这个时候调度器就从刚刚创建好的任务中选择一个优先级最高的任务开始运行。

- 任务实体通常是一个不带返回值的无限循环的 C 函数，函数体必须有阻塞的情况出现，不然任务（如果优先权恰好是最高）会一直在 while 循环里面执行，导致其它任务没有执行的机会。

## 2. 启动任务后启动调度器

第二种我称之为小心翼翼， 十分谨慎法。这种方法是在 main 函数中将硬件和 RTOS 系统先初始化好，然后创建一个启动任务后就启动调度器，然后在启动任务里面创建各种应用任务，当所有任务都创建成功后，启动任务把自己删除：

```c
int main (void)
{
    // 硬件初始化 
    HardWare_Init(); 
    // RTOS 系统初始化 
    RTOS_Init(); 
    // 创建一个任务 
    RTOS_TaskCreate(AppTaskCreate);
    // 启动 RTOS，开始调度 
    RTOS_Start(); 
}
// 起始任务，在里面创建任务
void AppTaskCreate(void *arg) 
{
    // 创建任务 1，然后执行 
    RTOS_TaskCreate(Task1); 
    // 当任务 1 阻塞时，继续创建任务 2，然后执行 
    RTOS_TaskCreate(Task2);
    // 当任务创建完成， 删除起始任务 
    RTOS_TaskDelete(AppTaskCreate); 
}
void Task1(void *arg) 
{
    while (1)
    {
        // 任务实体，必须有阻塞的情况出现 
    }
}
void Task2(void *arg) 
{
    while (1)
    {
        // 任务实体，必须有阻塞的情况出现
    }
}
```

- 硬件初始化。来到硬件初始化这一步还属于裸机的范畴，我们可以把需要使用到的硬件都初始化好而且测试好，确保无误。

- RTOS 系统初始化。比如 RTOS 里面的全局变量的初始化，空闲任务的创建等。不同的 RTOS，它们的初始化有细微的差别。

- 创建一个开始任务。然后在这个初始任务里面创建各种应用任务。

- 启动 RTOS 调度器，开始任务调度。这个时候调度器就去执行刚刚创建好的初始任务。

- 我们通常说任务是一个不带返回值的无限循环的 C 函数，但是因为初始任务的特殊性，它不能是无限循环的，只执行一次后就关闭。在初始任务里面我们创建我们需要的各种任务。

- 创建任务。每创建一个任务后它都将进入就绪态，系统会进行一次调度，如果新创建的任务的优先级比初始任务的优先级高的话，那将去执行新创建的任务，当新的任务阻塞时再回到初始任务被打断的地方继续执行。反之，则继续往下创建新的任务，直到所有任务创建完成。

- 各种应用任务创建完成后，初始任务自己关闭自己，使命完成。

- 任务实体通常是一个不带返回值的无限循环的 C 函数，函数体必须有阻塞的情况出现，不然任务（如果优先权恰好是最高）会一直在 while 循环里面执行，其它任务没有执行的机会。

# 


