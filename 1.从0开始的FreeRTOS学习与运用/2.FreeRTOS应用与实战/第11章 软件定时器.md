# 第十一章 软件定时器

## 1. 软件定时器的基本概念

定时器，是指从指定的时刻开始，经过一个指定时间，然后触发一个超时事件，用户可以自定义定时器的周期与频率。类似生活中的闹钟，我们可以设置闹钟每天什么时候响，还能设置响的次数，是响一次还是每天都响。

定时器有硬件定时器和软件定时器之分：

硬件定时器是芯片本身提供的定时功能。一般是由外部晶振提供给芯片输入时钟，芯片向软件模块提供一组配置寄存器，接受控制输入，到达设定时间值后芯片中断控制器产生时钟中断。硬件定时器的精度一般很高，可以达到纳秒级别，并且是中断触发方式。

软件定时器，软件定时器是由操作系统提供的一类系统接口，它构建在硬件定时器基础之上，使系统能够提供不受硬件定时器资源限制的定时器服务，它实现的功能与硬件定时器也是类似的。

使用硬件定时器时，每次在定时时间到达之后就会自动触发一个中断，用户在中断中处理信息；而使用软件定时器时，需要我们在创建软件定时器时指定时间到达后要调用的函数（也称超时函数/回调函数，为了统一，下文均用回调函数描述），在回调函数中处理信息。

注意：软件定时器回调函数的上下文是任务， 下文所说的定时器均为软件定时器。

软件定时器在被创建之后，当经过设定的时钟计数值后会触发用户定义的回调函数。定时精度与系统时钟的周期有关。一般系统利用 SysTick 作为软件定时器的基础时钟， 软件定时器的回调函数类似硬件的中断服务函数，所以， 回调函数也要快进快出，而且回调函数中不能有任何阻塞任务运行的情况（软件定时器回调函数的上下文环境是任务） ，比如 vTaskDelay()以及 其它能阻 塞任务运 行的函数 ，两次触发 回调函数 的时间间 隔xTimerPeriodInTicks 叫定时器的定时周期。

FreeRTOS 操作系统提供软件定时器功能，软件定时器的使用相当于扩展了定时器的数量，允许创建更多的定时业务。

FreeRTOS 提供的软件定时器支持单次模式和周期模式， 单次模式和周期模式的定时时间到之后都会调用软件定时器的回调函数，用户可以在回调函数中加入要执行的工程代码。

单次模式：当用户创建了定时器并启动了定时器后，定时时间到了，只执行一次回调函数之后就将该定时器进入休眠状态，不再重新执行。

周期模式：这个定时器会按照设置的定时时间循环执行回调函数，直到用户将定时器删除

![屏幕截图 2025-03-07 125258.png](https://raw.githubusercontent.com/hazy1k/My-drawing-bed/main/2025/03/07-12-53-13-屏幕截图%202025-03-07%20125258.png)

FreeRTOS 通过一个 prvTimerTask 任务（也叫守护任务 Daemon）管理软定时器，它是在启动调度器时自动创建的， 为了满足用户定时需求。 prvTimerTask 任务会在其执行期间检查用户启动的时间周期溢出的定时器，并调用其回调函数。 只有设置 FreeRTOSConfig.h中的宏定义 configUSE_TIMERS 设置为 1 ，将相关代码编译进来，才能正常使用软件定时器相关功能。

## 2. 软件定时器应用场景

在很多应用中，我们需要一些定时器任务，硬件定时器受硬件的限制，数量上不足以满足用户的实际需求，无法提供更多的定时器，那么可以采用软件定时器来完成，由软件定时器代替硬件定时器任务。 但需要注意的是软件定时器的精度是无法和硬件定时器相比的， 而且在软件定时器的定时过程中是极有可能被其它中断所打断，因为软件定时器的执行上下文环境是任务。所以，软件定时器更适用于对时间精度要求不高的任务，一些辅助型的任务。

## 3. 软件定时器的精度

在操作系统中，通常软件定时器以系统节拍周期为计时单位。系统节拍是系统的心跳节拍，表示系统时钟的频率，就类似人的心跳， 1s 能跳动多少下，系统节拍配置为configTICK_RATE_HZ，该宏在 FreeRTOSConfig.h 中有定义，默认是 1000。那么系统的时钟节拍周期就为 1ms（1s 跳动 1000 下，每一下就为 1ms）。软件定时器的所定时数值必须是这个节拍周期的整数倍，例如节拍周期是 10ms，那么上层软件定时器定时数值只能是10ms， 20ms， 100ms 等，而不能取值为 15ms。由于节拍定义了系统中定时器能够分辨的精确度，系统可以根据实际系统 CPU 的处理能力和实时性需求设置合适的数值，系统节拍周期的值越小，精度越高，但是系统开销也将越大，因为这代表在 1 秒中系统进入时钟中断的次数也就越多。

## 4. 软件定时器实验

软件定时器实验是在 FreeRTOS 中创建了两个软件定时器，其中一个软件定时器是单次模式， 5000 个 tick 调用一次回调函数，另一个软件定时器是周期模式， 1000 个 tick 调用

一次回调函数，在回调函数中输出相关信息

```c
/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "event_groups.h"
/* 其他头文件 */
#include "uart.h"
#include "led.h"
#include "key.h"

/* 任务句柄 */
static TaskHandle_t AppTaskCreate_Handle = NULL; // 创建任务句柄

static TimerHandle_t Swtmr1_Handle = NULL; // 软件定时器1句柄
static TimerHandle_t Swtmr2_Handle = NULL; // 软件定时器2句柄

/* 内核对象句柄 */
/* 全局变量声明 */
static uint32_t TmrCb_Count1 = 0; // 记录软件定时器1回调函数执行次数
static uint32_t TmrCb_Count2 = 0; // 记录软件定时器2回调函数执行次数
/* 宏定义 */


/* 任务函数声明 */
static void AppTaskCreate(void); // 创建任务函数

static void Swtmr1_Callback(void* pvParameters); 
static void Swtmr2_Callback(void* pvParameters); 

static void BSP_Init(void); // 板级初始化函数

// 主函数启动流程
/*
    1.BSP初始化
    2.创建APP任务
    3.启动FreeRTOS,开启调度
*/
int main(void)
{
    BaseType_t xReturn = pdPASS; // 定义一个创建信息返回值，默认为pdPASS
    BSP_Init(); // 板级初始化
    printf("FreeRTOS软件定时器实验\r\n");
    // 创建AppTaskCreate任务   
    xReturn = xTaskCreate((TaskFunction_t )AppTaskCreate,
                        (const char*)"AppTaskCreate",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)1, 
                        (TaskHandle_t*)&AppTaskCreate_Handle); 
    if(xReturn == pdPASS)
    {
        vTaskStartScheduler(); // 启动FreeRTOS
    }
    else
    {
        return -1;
    }
    while(1);
}

// 为了方便管理，所有任务创建函数都在AppTaskCreate中实现
static void AppTaskCreate(void)
{
  taskENTER_CRITICAL(); // 进入临界区

  Swtmr1_Handle = xTimerCreate((const char*)"AutoReloadTimer", // 定时器任务名称
                            (TickType_t)1000, // 定时器周期1000(tick)
                            (UBaseType_t)pdTRUE, // 周期模式
                            (void*)1, // 每个计时器分配一个索引的唯一ID
                            (TimerCallbackFunction_t)Swtmr1_Callback); // 定时器回调函数
  if(Swtmr1_Handle != NULL)
  {
    xTimerStart(Swtmr1_Handle, 0); // 启动定时器(周期模式)
  }
  Swtmr2_Handle = xTimerCreate((const char*)"OneShotTimer", // 定时器任务名称
                            (TickType_t)500, // 定时器周期5000(tick)
                            (UBaseType_t)pdFALSE, // 单次模式
                            (void*)2, // 每个计时器分配一个索引的唯一ID
                            (TimerCallbackFunction_t)Swtmr2_Callback); // 定时器回调函数
  if(Swtmr2_Handle != NULL)
  {
    xTimerStart(Swtmr2_Handle, 0); // 启动定时器(单次模式)
  }

  vTaskDelete(AppTaskCreate_Handle);
  taskEXIT_CRITICAL(); // 退出临界区
}


// 周期定时器1回调函数
static void Swtmr1_Callback(void* pvParameters)
{
  TickType_t tick_num1;
  TmrCb_Count1++; // 记录软件定时器1回调函数执行次数
  tick_num1 = xTaskGetTickCount(); // 获取滴答定时器的计数值
  LED1_TOGGLE();
  printf("软件定时器1回调函数执行次数：%d，滴答定时器计数值：%d\r\n", TmrCb_Count1, tick_num1);
}

// 单次定时器2回调函数
static void Swtmr2_Callback(void* pvParameters)
{
  TickType_t tick_num2;
  TmrCb_Count2++;
  tick_num2 = xTaskGetTickCount(); // 获取滴答定时器的计数值
  printf("软件定时器2回调函数执行次数：%d，滴答定时器计数值：%d\r\n", TmrCb_Count2, tick_num2);
}

// 板级初始化函数
static void BSP_Init(void)
{
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); // 设置中断优先级分组4
    LED_Init();
    USART_Config();
    Key_GPIO_Config();
}
```
