# 第二章 创建任务（静态内存）

## 1. 硬件初始化

本章创建的任务需要用到开发板上的 LED，所以先要将 LED 相关的函数初始化好，为了方便以后统一管理板级外设的初始化，我们在 main.c 文件中创建一个 BSP_Init()函数，专门用于存放板级外设初始化函数， 具体见代码：

```c
// 板级外设初始化，所有板子上的初始化均可放在这个函数里面
static void BSP_Init(void)
{
    /*
    STM32 中断优先级分组为 4，即 4bit 都用来表示抢占优先级，范围为： 0~15
    优先级分组只需要分组一次即可，以后如果有其他的任务需要用到中断，
    都统一用这个优先级分组，千万不要再分组，切忌。
    */
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
    // LED 初始化 
    LED_GPIO_Config();
    // 串口初始化 
    USART_Config();
}
```

执行到 BSP_Init()函数的时候， 操作系统完全都还没有涉及到， 即 BSP_Init()函数所做的工作跟我们以前编写的裸机工程里面的硬件初始化工作是一模一样的。运行完 BSP_Init ()函数， 接下来才慢慢启动操作系统， 最后运行创建好的任务。 有时候任务创建好， 整个系统跑起来了， 可想要的实验现象就是出不来， 比如 LED 不会亮，串口没有输出， LCD 没有显示等等。

如果是初学者，这个时候就会心急如焚，四处求救，那怎么办？这个时候如何排除是硬件的问题还是系统的问题，这里面有个小小的技巧，即在硬件初始化好之后，顺便测试下硬件，测试方法跟裸机编程一样，具体实现见代码：

```c
// 开发板硬件 bsp 头文件 
#include "bsp_led.h"
#include "bsp_usart.h"

static void BSP_Init(void)
{
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
    // LED 初始化 
    LED_GPIO_Config(); 
    // 测试硬件是否正常工作
    LED1_ON;
    // 其它硬件初始化和测试 
    // 让程序停在这里，不再继续往下执行 
    while (1); 
    // 串口初始化
    USART_Config();
}
```

- 初始化硬件后，顺便测试硬件，看下硬件是否正常工作。

- 可以继续添加其它的硬件初始化和测试。硬件确认没有问题之后，硬件测试代码可删可不删，因为 BSP_Init()函数只执行一遍。

- 方便测试硬件好坏，让程序停在这里，不再继续往下执行，当测试完毕后，这个 while(1);必须删除。

## 2. 创建单任务—SRAM静态内存

这里，我们创建一个单任务，任务使用的栈和任务控制块都使用静态内存，即预先定义好的全局变量，这些预先定义好的全局变量都存在内部的 SRAM 中。

### 2.1 定义任务函数

任务实际上就是一个无限循环且不带返回值的 C 函数。目前，我们创建一个这样的任务，让开发板上面的 LED 灯以 500ms 的频率闪烁，具体实现见代码：

```c
static void LED_Task(void* parameter)
{
    while(1)
    {
        LED1_ON;    
        vTaskDelay(500); // 延时 500 个 tick 
        LED1_OFF;
        vTaskDelay(500); // 延时 500 个 tick 
    }
}
```

- 任务必须是一个死循环，否则任务将通过 LR 返回，如果 LR 指向了非法的内存就会产生 HardFault_Handler，而 FreeRTOS 指向一个死循环，那么任务返回之后就在死循环中执行，这样子的任务是不安全的，所以避免这种情况，任务一般都是死循环并且无返回值的。我们的 AppTaskCreate 任务，执行一次之后就进行删除，则不影响系统运行，所以，只执行一次的任务在执行完毕要记得及时删除。

- 任务里面的延时函数必须使用 FreeRTOS 里面提供的延时函数，并不能使用我们裸机编程中的那种延时。这两种的延时的区别是 FreeRTOS 里面的延时是阻塞延时，即调用 vTaskDelay()函数的时候，当前任务会被挂起，调度器会切换到其它就绪的任务，从而实现多任务。如果还是使用裸机编程中的那种延时，那么整个任务就成为了一个死循环，如果恰好该任务的优先级是最高的，那么系统永远都是在这个任务中运行，比它优先级更低的任务无法运行，根本无法实现多任务。

### 2.2 空闲任务与定时器任务堆栈函数实现

当我们使用了静态创建任务的时候， configSUPPORT_STATIC_ALLOCATION 这个宏定义必须为1在 FreeRTOSConfig.h 文 件 中 ），并且我们需要实现两个函数 vApplicationGetIdleTaskMemory()与 vApplicationGetTimerTaskMemory()，这两个函数是用户设定的空闲（Idle）任务与定时器（Timer）任务的堆栈大小，必须由用户自己分配，而不能是动态分配，具体见代码：

```c
// 空闲任务任务堆栈 
static StackType_t Idle_Task_Stack[configMINIMAL_STACK_SIZE];
// 定时器任务堆栈 
static StackType_t Timer_Task_Stack[configTIMER_TASK_STACK_DEPTH];
// 空闲任务控制块 
static StaticTask_t Idle_Task_TCB;	
// 定时器任务控制块 
static StaticTask_t Timer_Task_TCB;

// 获取空闲任务的任务堆栈和任务控制块内存
void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer,  // 任务控制块内存 
								                   StackType_t **ppxIdleTaskStackBuffer, // 任务堆栈内存 
								                   uint32_t *pulIdleTaskStackSize)       // 任务堆栈大小
{
	*ppxIdleTaskTCBBuffer=&Idle_Task_TCB;    // 任务控制块内存 
	*ppxIdleTaskStackBuffer=Idle_Task_Stack; // 任务堆栈内存 
	*pulIdleTaskStackSize=configMINIMAL_STACK_SIZE; // 任务堆栈大小
}

// 获取定时器任务的任务堆栈和任务控制块内存
void vApplicationGetTimerTaskMemory(StaticTask_t **ppxTimerTaskTCBBuffer,  // 定时器任务控制块内存 
									                  StackType_t **ppxTimerTaskStackBuffer, // 定时器任务堆栈内存 
									                  uint32_t *pulTimerTaskStackSize)       // 定时器任务堆栈大小
{
	*ppxTimerTaskTCBBuffer=&Timer_Task_TCB;   // 任务控制块内存 
	*ppxTimerTaskStackBuffer=Timer_Task_Stack;// 任务堆栈内存 
	*pulTimerTaskStackSize=configTIMER_TASK_STACK_DEPTH;// 任务堆栈大小
}
```

### 2.3 定义任务栈

目前我们只创建了一个任务，当任务进入延时的时候，因为没有另外就绪的用户任务，那么系统就会进入空闲任务，空闲任务是 FreeRTOS 系统自己启动的一个任务，优先级最低。当整个系统都没有就绪任务的时候，系统必须保证有一个任务在运行，空闲任务就是为这个设计的。当用户任务延时到期，又会从空闲任务切换回用户任务。

在 FreeRTOS 系统中，每一个任务都是独立的，他们的运行环境都单独的保存在他们的栈空间当中。那么在定义好任务函数之后，我们还要为任务定义一个栈，目前我们使用的是静态内存，所以任务栈是一个独立的全局变量，具体见代码。

任务的栈占用的是 MCU 内部的 RAM，当任务越多的时候，需要使用的栈空间就越大，即需要使用的RAM 空间就越多。一个 MCU 能够支持多少任务，就得看你的 RAM 空间有多少。

```c
// AppTaskCreate任务任务堆栈
static StackType_t AppTaskCreate_Stack[128];
// LED任务堆栈 
static StackType_t LED_Task_Stack[128];
```

在大多数系统中需要做栈空间地址对齐，在 FreeRTOS 中是以 8 字节大小对齐，并且会检查堆栈是否已经对齐，其中 portBYTE_ALIGNMENT 是在 portmacro.h 里面定义的一个宏，其值为 8，就是配置为按 8 字节对齐，当然用户可以选择按 1、 2、 4、 8、 16、 32 等字节对齐，目前默认为 8。

### 2.4 定义任务控制块

定义好任务函数和任务栈之后，我们还需要为任务定义一个任务控制块，通常我们称这个任务控制块为任务的身份证。在 C 代码上，任务控制块就是一个结构体，里面有非常多的成员，这些成员共同描述了任务的全部信息，具体见代码：

```c
// AppTaskCreate 任务控制块
static StaticTask_t AppTaskCreate_TCB;
// AppTaskCreate 任务控制块 
static StaticTask_t LED_Task_TCB;
```

### 2.5 静态创建任务

一个任务的三要素是任务主体函数，任务栈，任务控制块，那么怎么样把这三个要素联合在一起？ FreeRTOS 里面有一个叫静态任务创建函数 xTaskCreateStatic()，它就是干这个活的。 它将任务主体函数， 任务栈（静态的）和任务控制块（静态的）这三者联系在一起，让任务可以随时被系统启动，具体见代码

```c
// 创建 AppTaskCreate 任务
AppTaskCreate_Handle = xTaskCreateStatic((TaskFunction_t)AppTaskCreate,// 任务函数
															            (const char*)"AppTaskCreate",		 // 任务名称
															            (uint32_t)128,	// 任务堆栈大小
															            (void*)NULL,		// 传递给任务函数的参数
															            (UBaseType_t)3, // 任务优先级
															            (StackType_t*)AppTaskCreate_Stack,	// 任务堆栈
															            (StaticTask_t*)&AppTaskCreate_TCB);	// 任务控制块   
															
if(NULL != AppTaskCreate_Handle) // 创建成功
vTaskStartScheduler();   // 启动任务，开启调度 
```

- 任务入口函数，即任务函数的名称，需要我们自己定义并且实现。

- 任务名字，字符串形式， 最大长度由 FreeRTOSConfig.h 中定义configMAX_TASK_NAME_LEN 宏指定，多余部分会被自动截掉，这里任务名字最好要与任务函数入口名字一致，方便进行调试。

- 任务堆栈大小，单位为字，在 32 位的处理器下（STM32），一个字等于 4 个字节，那么任务大小就为 128 * 4 字节。

- 任务入口函数形参，不用的时候配置为 0 或者 NULL 即可。

- 务 的优 先级 。优 先级 范围 根 据 FreeRTOSConfig.h 中 的 宏configMAX_PRIORITIES 决定， 如果使能 configUSE_PORT_OPTIMISED_TASK_SELECTION，这个宏定义，则最多支持 32 个优先级；如果不用特殊方法查找下一个运行的任务，那么则不强制要求限制最大可用优先级数目。在 FreeRTOS中， 数值越大优先级越高， 0 代表最低优先级。

- 任务栈起始地址， 只有在使用静态内存的时候才需要提供， 在使用动态内存的时候会根据提供的任务栈大小自动创建。

- 任务控制块指针，在使用静态内存的时候，需要给任务初始化函数 xTaskCreateStatic()传递预先定义好的任务控制块的指针。在使用动态内存的时候，任务创建函数 xTaskCreate()会返回一个指针指向任务控制块，该任务控制块是 xTaskCreate()函数里面动态分配的一块内存

### 2.6 启动任务

当任务创建好后，是处于任务就绪（Ready） ，在就绪态的任务可以参与操作系统的调度。但是此时任务仅仅是创建了，还未开启任务调度器，也没创建空闲任务与定时器任务（如果使能了 configUSE_TIMERS 这个宏定义），那这两个任务就是在启动任务调度器中实现， 每个操作系统， 任务调度器只启动一次，之后就不会再次执行了， FreeRTOS 中启动任务调度器的函数是 vTaskStartScheduler()，并且启动任务调度器的时候就不会返回，从此任务管理都由FreeRTOS管理，此时才是真正进入实时操作系统中的第一步，具体见代码

```c
// 启动任务，开启调度 
vTaskStartScheduler();
```


