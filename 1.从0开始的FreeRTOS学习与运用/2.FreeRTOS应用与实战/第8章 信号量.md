# 第八章 信号量

同志们， 回想一下， 你是否在裸机编程中这样使用过一个变量：用于标记某个事件是否发生，或者标志一下某个东西是否正在被使用，如果是被占用了的或者没发生，我们就不对它进行操作。

## 1. 信号量基本概念

信号量（Semaphore）是一种实现任务间通信的机制，可以实现任务之间同步或临界资源的互斥访问， 常用于协助一组相互竞争的任务来访问临界资源。在多任务系统中，各任务之间需要同步或互斥实现临界资源的保护，信号量功能可以为用户提供这方面的支持。

抽象的来讲，信号量是一个非负整数，所有获取它的任务都会将该整数减一（获取它当然是为了使用资源），当该整数值为零时，所有试图获取它的任务都将处于阻塞状态。通常一个信号量的计数值用于对应有效的资源数，表示剩下的可被占用的互斥资源数。其值的含义分两种情况：

- 0： 表示没有积累下来的释放信号量操作，且有可能有在此信号量上阻塞的任务。

- 正值，表示有一个或多个释放信号量操作。

### 1.1 二值信号量

二值信号量既可以用于临界资源访问也可以用于同步功能。

二值信号量和互斥信号量（以下使用互斥量表示互斥信号量） 非常相似，但是有一些细微差别：互斥量有优先级继承机制， 二值信号量则没有这个机制。这使得二值信号量更偏向应用于同步功能（任务与任务间的同步或任务和中断间同步）， 而互斥量更偏向应用于临界资源的访问。

用作同步时，信号量在创建后应被置为空，任务 1 获取信号量而进入阻塞，任务 2 在某种条件发生后，释放信号量，于是任务 1 获得信号量得以进入就绪态，如果任务 1 的优先级是最高的，那么就会立即切换任务，从而达到了两个任务间的同步。同样的，在中断服务函数中释放信号量， 任务 1 也会得到信号量，从而达到任务与中断间的同步。

还记得我们经常说的中断要快进快出吗，在裸机开发中我们经常是在中断中做一个标记，然后在退出的时候进行轮询处理，这个就是类似我们使用信号量进行同步的，当标记发生了，我们再做其他事情。在 FreeRTOS 中我们用信号量用于同步，任务与任务的同步，中断与任务的同步，可以大大提高效率。

可以将二值信号量看作只有一个消息的队列， 因此这个队列只能为空或满（因此称为二值），我们在运用的时候只需要知道队列中是否有消息即可，而无需关注消息是什么。

### 1.2 计数信号量

二进制信号量可以被认为是长度为 1 的队列，而计数信号量则可以被认为长度大于 1的队列，信号量使用者依然不必关心存储在队列中的消息，只需关心队列是否有消息即可。

顾名思义，计数信号量肯定是用于计数的，在实际的使用中，我们常将计数信号量用于事件计数与资源管理。每当某个事件发生时，任务或者中断将释放一个信号量（信号量计数值加 1），当处理被事件时（一般在任务中处理），处理任务会取走该信号量（信号量计数值减 1），信号量的计数值则表示还有多少个事件没被处理。此外，系统还有很多资源，我们也可以使用计数信号量进行资源管理，信号量的计数值表示系统中可用的资源数目，任务必须先获取到信号量才能获取资源访问权，当信号量的计数值为零时表示系统没有可用的资源，但是要注意，在使用完资源的时候必须归还信号量，否则当计数值为 0的时候任务就无法访问该资源了。

计数型信号量允许多个任务对其进行操作，但限制了任务的数量。比如有一个停车场，里面只有 100 个车位，那么能停的车只有 100 辆，也相当于我们的信号量有 100 个，假如一开始停车场的车位还有 100 个，那么每进去一辆车就要消耗一个停车位，车位的数量就要减一，对应的，我们的信号量在使用之后也需要减一，当停车场停满了 100 辆车的时候，此时的停车位为 0，再来的车就不能停进去了，否则将造成事故，也相当于我们的信号量为 0，后面的任务对这个停车场资源的访问也无法进行，当有车从停车场离开的时候，车位又空余出来了，那么，后面的车就能停进去了，我们信号量的操作也是一样的，当我们释放了这个资源，后面的任务才能对这个资源进行访问。

### 1.3 互斥信号量

互斥信号量其实是特殊的二值信号量，由于其特有的优先级继承机制从而使它更适用于简单互锁，也就是保护临界资源（什么是优先级继承在后续相信讲解） 。

用作互斥时，信号量创建后可用信号量个数应该是满的， 任务在需要使用临界资源时， （临界资源是指任何时刻只能被一个任务访问的资源） ，先获取互斥信号量，使其变空，这样其他任务需要使用临界资源时就会因为无法获取信号量而进入阻塞，从而保证了临界资源的安全。

在操作系统中，我们使用信号量的很多时候是为了给临界资源建立一个标志，信号量表示了该临界资源被占用情况。这样，当一个任务在访问临界资源的时候，就会先对这个资源信息进行查询，从而在了解资源被占用的情况之后，再做处理，从而使得临界资源得到有效的保护。互斥信号量其实是特殊的二值信号量，由于其特有的优先级继承机制从而使它更适用于简单互锁，也就是保护临界资源（什么是优先级继承在后续相信讲解） 。

用作互斥时，信号量创建后可用信号量个数应该是满的， 任务在需要使用临界资源时， （临界资源是指任何时刻只能被一个任务访问的资源） ，先获取互斥信号量，使其变空，这样其他任务需要使用临界资源时就会因为无法获取信号量而进入阻塞，从而保证了临界资源的安全。

### 1.4 递归信号量

递归信号量，见文知义，递归嘛，就是可以重复获取调用的，本来按照信号量的特性，每获取一次可用信号量个数就会减少一个，但是递归则不然， 对于已经获取递归互斥量的任务可以重复获取该递归互斥量， 该任务拥有递归信号量的所有权。 任务成功获取几次递归互斥量， 就要返还几次，在此之前递归互斥量都处于无效状态， 其他任务无法获取， 只有持有递归信号量的任务才能获取与释放。

## 2. 二值信号量应用场景

在嵌入式操作系统中二值信号量是任务间、 任务与中断间同步的重要手段，信号量使用最多的一般都是二值信号量与互斥信号量（互斥信号量在下一章讲解） 。 为什么叫二值信号量呢？因为信号量资源被获取了，信号量值就是 0，信号量资源被释放，信号量值就是 1，把这种只有 0 和 1 两种情况的信号量称之为二值信号量。

在多任务系统中，我们经常会使用这个二值信号量，比如，某个任务需要等待一个标记，那么任务可以在轮询中查询这个标记有没有被置位， 但是这样子做，就会很消耗 CPU资源并且妨碍其它任务执行， 更好的做法是任务的大部分时间处于阻塞状态（允许其它任务执行），直到某些事件发生该任务才被唤醒去执行。可以使用二进制信号量实现这种同步， 当任务取信号量时，因为此时尚未发生特定事件，信号量为空，任务会进入阻塞状态；当事件的条件满足后，任务/中断便会释放信号量， 告知任务这个事件发生了， 任务取得信号量便被唤醒去执行对应的操作，任务执行完毕并不需要归还信号量， 这样子的 CPU 的效率可以大大提高， 而且实时响应也是最快的。

再比如某个任务使用信号量在等中断的标记的发生，在这之前任务已经进入了阻塞态，在等待着中断的发生，当在中断发生之后，释放一个信号量，也就是我们常说的标记，当它退出中断之后，操作系统会进行任务的调度，如果这个任务能够运行，系统就会把等待这个任务运行起来，这样子就大大提高了我们的效率。

二值信号量在任务与任务中同步的应用场景：假设我们有一个温湿度的传感器，假设是 1s 采集一次数据，那么我们让他在液晶屏中显示数据出来，这个周期也是要 1s 一次的，如果液晶屏刷新的周期是 100ms 更新一次，那么此时的温湿度的数据还没更新，液晶屏根本无需刷新，只需要在 1s 后温湿度数据更新的时候刷新即可，否则 CPU 就是白白做了多次的无效数据更新， CPU 的资源就被刷新数据这个任务占用了大半，造成 CPU 资源浪费，如果液晶屏刷新的周期是 10s 更新一次，那么温湿度的数据都变化了 10 次，液晶屏才来更新数据，那拿这个产品有啥用，根本就是不准确的，所以，还是需要同步协调工作，在温湿度采集完毕之后，进行液晶屏数据的刷新，这样子，才是最准确的，并且不会浪费 CPU的资源。

同理， 二值信号量在任务与中断同步的应用场景：我们在串口接收中，我们不知道啥时候有数据发送过来，有一个任务是做接收这些数据处理，总不能在任务中每时每刻都在任务查询有没有数据到来，那样会浪费 CPU 资源，所以在这种情况下使用二值信号量是很好的办法，当没有数据到来的时候， 任务就进入阻塞态，不参与任务的调度，等到数据到来了，释放一个二值信号量， 任务就立即从阻塞态中解除，进入就绪态，然后运行的时候处理数据，这样子系统的资源就会很好的被利用起来。

## 3. 二值信号量运作机制

创建信号量时， 系统会为创建的信号量对象分配内存，并把可用信号量初始化为用户自定义的个数， 二值信号量的最大可用信号量个数为 1。

二值信号量获取， 任何任务都可以从创建的二值信号量资源中获取一个二值信号量，获取成功则返回正确， 否则任务会根据用户指定的阻塞超时时间来等待其它任务/中断释放信号量。 在等待这段时间，系统将任务变成阻塞态， 任务将被挂到该信号量的阻塞等待列表中。

在二值信号量无效的时候，假如此时有任务获取该信号量的话，那么任务将进入阻塞状态

![屏幕截图 2025-03-05 123615.png](https://raw.githubusercontent.com/hazy1k/My-drawing-bed/main/2025/03/05-12-36-27-屏幕截图%202025-03-05%20123615.png)

假如某个时间中断/任务释放了信号量，那么，由于获取无效信号量而进入阻塞态的任务将获得信号量并且恢复为就绪态

![屏幕截图 2025-03-05 123659.png](https://raw.githubusercontent.com/hazy1k/My-drawing-bed/main/2025/03/05-12-37-03-屏幕截图%202025-03-05%20123659.png)

![屏幕截图 2025-03-05 123712.png](https://raw.githubusercontent.com/hazy1k/My-drawing-bed/main/2025/03/05-12-37-16-屏幕截图%202025-03-05%20123712.png)

## 4. 计数信号量运作机制

计数信号量可以用于资源管理，允许多个任务获取信号量访问共享资源，但会限制任务的最大数目。访问的任务数达到可支持的最大数目时，会阻塞其他试图获取该信号量的任务，直到有任务释放了信号量。这就是计数型信号量的运作机制，虽然计数信号量允许多个任务访问同一个资源，但是也有限定，比如某个资源限定只能有 3 个任务访问，那么第 4 个任务访问的时候，会因为获取不到信号量而进入阻塞，等到有任务（比如任务 1）释放掉该资源的时候，第 4 个任务才能获取到信号量从而进行资源的访问

![屏幕截图 2025-03-05 123808.png](https://raw.githubusercontent.com/hazy1k/My-drawing-bed/main/2025/03/05-12-38-13-屏幕截图%202025-03-05%20123808.png)

## 5. 信号量实验

### 5.1 二值信号量同步实验

信号量同步实验是在 FreeRTOS 中创建了两个任务，一个是获取信号量任务，一个是释放互斥量任务，两个任务独立运行，获取信号量任务是一直在等待信号量，其等待时间是 portMAX_DELAY，等到获取到信号量之后， 任务开始执行任务代码，如此反复等待另外任务释放的信号量。

释放信号量任务在检测按键是否按下，如果按下则释放信号量，此时释放信号量会唤醒获取任务，获取任务开始运行，然后形成两个任务间的同步，因为如果没按下按键，那么信号量就不会释放，只有当信号量释放的时候，获取信号量的任务才会被唤醒，如此一

来就达到任务与任务的同步， 同时程序的运行会在串口打印出相关信息

```c
/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h" 
#include "semphr.h"
/* 其他头文件 */
#include "uart.h"
#include "led.h"
#include "key.h"

/* 任务句柄 */
static TaskHandle_t AppTaskCreate_Handle = NULL; // 创建任务句柄

static TaskHandle_t Receive_Task_Handle = NULL; // 接收任务句柄
static TaskHandle_t Send_Task_Handle = NULL; // 发送任务句柄

/* 内核对象句柄 */
SemaphoreHandle_t BinarySem_Handle = NULL; // 二值信号量句柄
/* 全局变量声明 */
/* 宏定义 */


/* 任务函数声明 */
static void AppTaskCreate(void); // 创建任务函数

static void Receive_Task(void* pvParameters); // 接收任务函数
static void Send_Task(void* pvParameters); // 发送任务函数

static void BSP_Init(void); // 板级初始化函数

// 主函数启动流程
/*
    1.BSP初始化
    2.创建APP任务
    3.启动FreeRTOS,开启调度
*/
int main(void)
{
    BaseType_t xReturn = pdPASS; // 定义一个创建信息返回值，默认为pdPASS
    BSP_Init(); // 板级初始化
    printf("按下KEY1或者KEY2进行任务与任务间的同步\r\n");
    // 创建AppTaskCreate任务   
    xReturn = xTaskCreate((TaskFunction_t )AppTaskCreate,
                        (const char*    )"AppTaskCreate",
                        (uint16_t       )512,  
                        (void*          )NULL,
                        (UBaseType_t    )1, 
                        (TaskHandle_t*)&AppTaskCreate_Handle); 
    if(xReturn == pdPASS)
    {
        vTaskStartScheduler(); // 启动FreeRTOS
        printf("FreeRTOS Start Success\r\n");
    }
    else
    {
        printf("AppTaskCreate 创建失败！\r\n");
        return -1;
    }
    while(1);
}

// 为了方便管理，所有任务创建函数都在AppTaskCreate中实现
static void AppTaskCreate(void)
{
    BaseType_t xReturn = pdPASS;
    taskENTER_CRITICAL(); // 进入临界区

    BinarySem_Handle = xSemaphoreCreateBinary(); // 创建二值信号量
    if(BinarySem_Handle != NULL)
    {
        printf("二值信号量创建成功！\r\n");
    }
    xReturn = xTaskCreate((TaskFunction_t)Receive_Task,
                         (const char*)"Receive_Task",
                         (uint16_t)512,  
                         (void*)NULL,
                         (UBaseType_t)2,
                         (TaskHandle_t*)&Receive_Task_Handle);
    if(xReturn == pdPASS)
    {
        printf("接收任务创建成功！\r\n");
    }
    xReturn = xTaskCreate((TaskFunction_t)Send_Task,
                         (const char*)"Send_Task",
                         (uint16_t)512,  
                         (void*)NULL,
                         (UBaseType_t)3,
                         (TaskHandle_t*)&Send_Task_Handle);
    if(xReturn == pdPASS)
    {
        printf("发送任务创建成功！\r\n");
    }
    vTaskDelete(AppTaskCreate_Handle);

    taskEXIT_CRITICAL(); // 退出临界区
}

// 接收任务函数
static void Receive_Task(void* pvParameters)
{
    BaseType_t xReturn = pdPASS;
    while(1)
    {
        // 获取二值信号量xSemaphore
        xReturn = xSemaphoreTake(BinarySem_Handle, portMAX_DELAY);
        if(xReturn == pdTRUE)
        {
            printf("接收任务获取二值信号量成功！\r\n");
        }
        LED1_TOGGLE();
    }
}

// 发送任务函数
static void Send_Task(void* pvParameters)
{
    BaseType_t xReturn = pdPASS;
    while(1)
    {
        if(Key_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == KEY_ON)
        {
            xReturn = xSemaphoreGive(BinarySem_Handle); // 给出二值信号
            if(xReturn == pdTRUE)
            {
                printf("二值信号释放成功！\r\n");
            }
            else
            {
                printf("二值信号释放失败！\r\n");
            }
        }
        if(Key_Scan(KEY2_GPIO_PORT, KEY2_GPIO_PIN) == KEY_ON)
        {
            xReturn = xSemaphoreGive(BinarySem_Handle);
            if(xReturn == pdTRUE)
            {
                printf("二值信号释放成功！\r\n");
            }
            else
            {
                printf("二值信号释放失败！\r\n");
            }
        }
        vTaskDelay(20);
    }
}

// 板级初始化函数
static void BSP_Init(void)
{
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); // 设置中断优先级分组4
    LED_Init();
    USART_Config();
    Key_GPIO_Config();
}

```

### 5.2 计数信号量实验

计数型信号量实验是模拟停车场工作运行。在创建信号量的时候初始化 5 个可用的信号量，并且创建了两个任务：一个是获取信号量任务，一个是释放信号量任务，两个任务独立运行，获取信号量任务是通过按下 KEY1 按键进行信号量的获取，模拟停车场停车操作，其等待时间是 0，在串口调试助手输出相应信息。

释放信号量任务则是信号量的释放，释放信号量任务也是通过按下 KEY2 按键进行信号量的释放，模拟停车场取车操作，在串口调试助手输出相应信息

```c
/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h" 
#include "semphr.h"
/* 其他头文件 */
#include "uart.h"
#include "led.h"
#include "key.h"

/* 任务句柄 */
static TaskHandle_t AppTaskCreate_Handle = NULL; // 创建任务句柄

static TaskHandle_t Take_Task_Handle = NULL; 
static TaskHandle_t Give_Task_Handle = NULL; 

/* 内核对象句柄 */
SemaphoreHandle_t CountSem_Handle = NULL; // 计数信号量句柄
/* 全局变量声明 */
/* 宏定义 */

/* 任务函数声明 */
static void AppTaskCreate(void); // 创建任务函数

static void Take_Task(void* pvParameters);
static void Give_Task(void* pvParameters); 

static void BSP_Init(void); // 板级初始化函数

// 主函数启动流程
/*
    1.BSP初始化
    2.创建APP任务
    3.启动FreeRTOS,开启调度
*/
int main(void)
{
    BaseType_t xReturn = pdPASS; // 定义一个创建信息返回值，默认为pdPASS
    BSP_Init(); // 板级初始化
    printf("车位默认值5个，按下KEY1申请车位（也就是给信号量），按下KEY2释放车位（也就是释放信号量）\r\n");
    // 创建AppTaskCreate任务   
    xReturn = xTaskCreate((TaskFunction_t )AppTaskCreate,
                        (const char*)"AppTaskCreate",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)1, 
                        (TaskHandle_t*)&AppTaskCreate_Handle); 
    if(xReturn == pdPASS)
    {
        vTaskStartScheduler(); // 启动FreeRTOS
    }
    else
    {
        return -1;
    }
    while(1);
}

// 为了方便管理，所有任务创建函数都在AppTaskCreate中实现
static void AppTaskCreate(void)
{
    BaseType_t xReturn = pdPASS;
    taskENTER_CRITICAL(); // 进入临界区

    CountSem_Handle = xSemaphoreCreateCounting(5,5); // 创建计数信号量，初始值为5，最大值为5
    if(CountSem_Handle != NULL)
    {
        printf("计数信号量创建成功！\r\n");
    }
    xReturn = xTaskCreate((TaskFunction_t)Take_Task,
                         (const char*)"Take_Task",
                         (uint16_t)512,  
                         (void*)NULL,
                         (UBaseType_t)2,
                         (TaskHandle_t*)&Take_Task_Handle);
    if(xReturn == pdPASS)
    {
        printf("申请任务创建成功！\r\n");
    }
    xReturn = xTaskCreate((TaskFunction_t)Give_Task,
                         (const char*)"Give_Task",
                         (uint16_t)512,  
                         (void*)NULL,
                         (UBaseType_t)3,
                         (TaskHandle_t*)&Give_Task_Handle);
    if(xReturn == pdPASS)
    {
        printf("释放任务创建成功！\r\n");
    }
    vTaskDelete(AppTaskCreate_Handle);

    taskEXIT_CRITICAL(); // 退出临界区
}

// 申请任务函数
static void Take_Task(void* pvParameters)
{
    BaseType_t xReturn = pdTRUE;
    while(1)
    {
        if(Key_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == KEY_ON)
        {
            xReturn = xSemaphoreTake(CountSem_Handle, 0); // 申请计数信号量
            if(xReturn == pdTRUE)
            {
                printf("KEY1被按下，申请一个车位成功！\r\n");
            }
            else
            {
                printf("虽然KEY1被按下，但是车位已经满了！\r\n");
            }
        }
        vTaskDelay(20);
    }
}

// 释放任务函数
static void Give_Task(void* pvParameters)
{
    BaseType_t xReturn = pdTRUE;
    while(1)
    {
        if(Key_Scan(KEY2_GPIO_PORT, KEY2_GPIO_PIN) == KEY_ON)
        {
            xReturn = xSemaphoreGive(CountSem_Handle); // 释放计数信号量
            if(xReturn == pdTRUE)
            {
                printf("KEY2被按下，释放一个车位成功！\r\n");
            }
            else
            {
                printf("虽然KEY2被按下，但是车位已经空了！\r\n");
            }
        }
        vTaskDelay(20);
    }
}

// 板级初始化函数
static void BSP_Init(void)
{
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); // 设置中断优先级分组4
    LED_Init();
    USART_Config();
    Key_GPIO_Config();
}

```


