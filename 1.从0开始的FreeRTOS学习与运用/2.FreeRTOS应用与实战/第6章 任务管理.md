# 第六章 任务管理

## 1. 任务的基本概念

系统的角度看，任务是竞争系统资源的最小运行单元。 FreeRTOS 是一个支持多任务的操作系统。在 FreeRTOS 中，任务可以使用或等待 CPU、使用内存空间等系统资源，并独立于其他任务运行，任何数量的任务可以共享同一个优先级，如果宏configUSE_TIME_SLICING 定义为 1， 处于就绪态的多个相同优先级任务将会以时间片切换的方式共享处理器。

简而言之： FreeRTOS 的任务可认为是一系列独立任务的集合。每个任务在自己的环境中运行。在任何时刻，只有一个任务得到运行， FreeRTOS 调度器决定运行哪个任务。调度器会不断的启动、停止每一个任务，宏观看上去所有的任务都在同时在执行。作为任务，不需要对调度器的活动有所了解，在任务切入切出时保存上下文环境（寄存器值、堆栈内容）是调度器主要的职责。为了实现这点，每个 FreeRTOS 任务都需要有自己的栈空间。当任务切出时，它的执行环境会被保存在该任务的栈空间中，这样当任务再次运行时，就能从堆栈中正确的恢复上次的运行环境，任务越多，需要的堆栈空间就越大，而一个系统能运行多少个任务，取决于系统的可用的 SRAM。

FreeRTOS 的可以给用户提供多个任务单独享有独立的堆栈空间，系统可以决定任务的状态，决定任务是否可以运行， 同时还能运用内核的 IPC 通信资源，实现了任务之间的通信，帮助用户管理业务程序流程。这样用户可以将更多的精力投入到业务功能的实现中。

FreeRTOS 中的任务是抢占式调度机制，高优先级的任务可打断低优先级任务，低优先级任务必须在高优先级任务阻塞或结束后才能得到调度。 同时 FreeRTOS 也支持时间片轮转调度方式，只不过时间片的调度是不允许抢占任务的 CPU 使用权。

任务通常会运行在一个死循环中，也不会退出，如果一个任务不再需要，可以调用FreeRTOS 中的任务删除 API 函数接口显式地将其删除。

## 2. 任务调度器的基本概念

FreeRTOS 中提供的任务调度器是基于优先级的全抢占式调度：在系统中除了中断处理函数、调度器上锁部分的代码和禁止中断的代码是不可抢占的之外，系统的其他部分都是可以抢占的。系统理论上可以支持无数个优先级(0 ～ N，优先级数值越小的任务优先级越低， 0 为最低优先级，分配给空闲任务使用，一般不建议用户来使用这个优先级。假如使能了 configUSE_PORT_OPTIMISED_TASK_SELECTION 这个宏（在 FreeRTOSConfig.h 文件定义）， 一般强制限定最大可用优先级数目为 32。在一些资源比较紧张的系统中， 可以根据实际情况选择只支持 8 个或 32 个优先级的系统配置。在系统中，当有比当前任务优先级更高的任务就绪时，当前任务将立刻被换出，高优先级任务抢占处理器运行。

一个操作系统如果只是具备了高优先级任务能够“立即”获得处理器并得到执行的特点，那么它仍然不算是实时操作系统。因为这个查找最高优先级任务的过程决定了调度时间是否具有确定性，例如一个包含 n 个就绪任务的系统中，如果仅仅从头找到尾，那么这个时间将直接和 n 相关，而下一个就绪任务抉择时间的长短将会极大的影响系统的实时性。

FreeRTOS 内核中采用两种方法寻找最高优先级的任务，第一种是通用的方法，在就绪链表中查找从高优先级往低查找 uxTopPriority，因为在创建任务的时候已经将优先级进行排序，查找到的第一个 uxTopPriority 就是我们需要的任务，然后通过 uxTopPriority 获取对应的任务控制块。第二种方法则是特殊方法，利用计算前导零指令CLZ，直接在 uxTopReadyPriority 这个32位变量中直接得出uxTopPriority，这样子就知道哪一个优先级任务能够运行，这种调度算法比普通方法更快捷，但受限于平台（在 STM32 中我们就使用这种方法） 。

FreeRTOS 内核中也允许创建相同优先级的任务。相同优先级的任务采用时间片轮转方式进行调度（也就是通常说的分时调度器），时间片轮转调度仅在当前系统中无更高优先级就绪任务存在的情况下才有效。为了保证系统的实时性，系统尽最大可能地保证高优先级的任务得以运行。任务调度的原则是一旦任务状态发生了改变，并且当前运行的任务优先级小于优先级队列组中任务最高优先级时，立刻进行任务切换（除非当前系统处于中断处理程序中或禁止任务切换的状态）。

## 3. 任务状态迁移

FreeRTOS 系统中的每一个任务都有多种运行状态，他们之间的转换关系是怎么样的呢？从运行态任务变成阻塞态，或者从阻塞态变成就绪态，这些任务状态是如何进行迁移？下面就让我们一起了解任务状态迁移吧

![屏幕截图 2024-10-15 122417.png](https://raw.githubusercontent.com/hazy1k/My-drawing-bed/main/2024/10/15-12-24-32-屏幕截图%202024-10-15%20122417.png)

- 创建任务→就绪态（Ready）：任务创建完成后进入就绪态，表明任务已准备就绪，随时可以运行，只等待调度器进行调度。

- 就绪态→运行态（Running）：发生任务切换时，就绪列表中最高优先级的任务被执行，从而进入运行态。

- 运行态→就绪态：有更高优先级任务创建或者恢复后，会发生任务调度，此刻就绪列表中最高优先级任务变为运行态，那么原先运行的任务由运行态变为就绪态，依然在就绪列表中，等待最高优先级的任务运行完毕继续运行原来的任务（此处可以看做是 CPU 使用权被更高优先级的任务抢占了）。

- 运行态→阻塞态（Blocked）：正在运行的任务发生阻塞（挂起、延时读信号量等待）时，该任务会从就绪列表中删除，任务状态由运行态变成阻塞态，然后发生任务切换，运行就绪列表中当前最高优先级任务。

- 阻塞态→就绪态：阻塞的任务被恢复后（任务恢复、延时时间超时、读信号量超时或读到信号量等），此时被恢复的任务会被加入就绪列表，从而由阻塞态变成就绪态；如果此时被恢复任务的优先级高于正在运行任务的优先级，则会发生任务切换，将该任务将再次转换任务状态，由就绪态变成运行态。

- 就绪态、阻塞态、运行态→挂起态（Suspended）：任务可以通过调用 vTaskSuspend() API 函数都可以将处于任何状态的任务挂起，被挂起的任务得不到CPU 的使用权，也不会参与调度，除非它从挂起态中解除。

- 挂起态→就绪态：把一个挂起状态的任务恢复的唯 一 途 径 就 是调用 vTaskResume() 或 vTaskResumeFromISR() API 函数，如果此时被恢复任务的优先级高于正在运行任务的优先级，则会发生任务切换，将该任务将再次转换任务状态，由就绪态变成运行态。

## 4. 任务状态的概念

FreeRTOS 系统中的每一任务都有多种运行状态。系统初始化完成后，创建的任务就可以在系统中竞争一定的资源，由内核进行调度。

任务状态通常分为以下四种：

- 就绪（ Ready）：该任务在就绪列表中， 就绪的任务已经具备执行的能力，只等待调度器进行调度，新创建的任务会初始化为就绪态。

- 运行（Running）：该状态表明任务正在执行， 此时它占用处理器， FreeRTOS 调度器选择运行的永远是处于最高优先级的就绪态任务，当任务被运行的一刻，它的任务状态就变成了运行态。

- 阻塞（Blocked）： 如果任务当前正在等待某个时序或外部中断，我们就说这个任务处于阻塞状态，该任务不在就绪列表中。包含任务被挂起、 任务被延时、任务正在等待信号量、读写队列或者等待读写事件等。

- 挂起态(Suspended)： 处于挂起态的任务对调度器而言是不可见的， 让一个任务进入挂起状态的唯一办法就是调用 vTaskSuspend()函数；而把一个挂起状态的任务恢复的唯一途径就是调用vTaskResume() 或 vTaskResumeFromISR()函数，我们可以这么理解挂起态与阻塞态的区别，当任务有较长的时间不允许运行的时候，我们可以挂起任务，这样子调度器就不会管这个任务的任何信息，直到我们调用恢复任务的 API 函数；而任务处于阻塞态的时候，系统还需要判断阻塞态的任务是否超时，是否可以解除阻塞。

## 5. 常用的任务函数讲解

### 5.1 任务挂起函数

1. vTaskSuspend()

挂起指定任务。被挂起的任务绝不会得到 CPU 的使用权，不管该任务具有什么优先级。

任务可以通过调用 vTaskSuspend()函数都可以将处于任何状态的任务挂起，被挂起的任务得不到 CPU 的使用权，也不会参与调度，它相对于调度器而言是不可见的，除非它从挂起态中解除。任务挂起是我们经常使用的一个函数，下面一起看看任务挂起的源码吧，

```c
#if ( INCLUDE_vTaskSuspend == 1 ) // 任务挂起函数

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
		{
			// 如果在此处传递null，那么它正在被挂起的正在运行的任务
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
			traceTASK_SUSPEND( pxTCB );

			// 从就绪/阻塞列表中删除任务并放入挂起列表中
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			// 如果任务在等待事件，也从等待事件列表中移除
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			// 将任务状态添加到挂起列表中
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
		}
		taskEXIT_CRITICAL();

		if( xSchedulerRunning != pdFALSE )
		{
			/* 重置下一个任务的解除阻塞时间。
			重新计算一下还要多长时间执行下一个任务。
			如果下个任务的解锁，刚好是被挂起的那个任务，
			那么变量 NextTaskUnblockTime 就不对了，
			所以要重新从延时列表中获取一下。*/
			taskENTER_CRITICAL();
			{
				prvResetNextTaskUnblockTime();
			}
			taskEXIT_CRITICAL();
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
		{
			if( xSchedulerRunning != pdFALSE )
			{
				// 当前的任务已经被挂起。
				configASSERT( uxSchedulerSuspended == 0 );
				// 调度器在运行时，如果这个挂起的任务是当前任务，立即切换任务。
				portYIELD_WITHIN_API();
			}
			else
			{
				/* 调度器未运行(xSchedulerRunning == pdFALSE )，
				但 pxCurrentTCB 指向的任务刚刚被暂停，
				所以必须调整 pxCurrentTCB 以指向其他任务。
				首先调用函数 listCURRENT_LIST_LENGTH()
				判断一下系统中所有的任务是不是都被挂起了，
				也就是查看列表 xSuspendedTaskList
				的长度是不是等于 uxCurrentNumberOfTasks，
				事实上并不会发生这种情况，
				因为空闲任务是不允许被挂起和阻塞的，
				必须保证系统中无论如何都有一个任务可以运行 */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
				{
					/* 没有其他任务准备就绪，因此将 pxCurrentTCB 设置回 NULL，
					以便在创建下一个任务时 pxCurrentTCB 将被设置为指向它，
					实际上并不会执行到这里*/
					pxCurrentTCB = NULL;
				}
				else
				{
					// 有其他任务，则切换到其他任务
					vTaskSwitchContext();
				}
			}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
#endif /* INCLUDE_vTaskSuspend */
```

- 如果想要使用任务挂起函数 vTaskSuspend()则必须将宏定义INCLUDE_vTaskSuspend 配置为 1。

- xTaskToSuspend 是挂起指定任务的任务句柄， 任务必须为已创建的任务， 可以通过传递 NULL 来挂起任务自己。

- 利用任务句柄 xTaskToSuspend 来获取任务控制块，通过调用prvGetTCBFromHandle()API 函数得到对应的任务控制块。

- 从就绪/阻塞列表中删除即将要挂起的任务。然后更新"最高优先级变量 uxReadyPriorities"，目的是维护这个变量，这个变量的如下功能：
1. 在使用通用方法找到最高优先级任务时，它用来记录最高优先级任务的优先级。

2. 在使用硬件方法找到最高优先级任务时，它的每一位（共 32bit）的状态代表这个优先级上边，有没有就绪的任务
- 如果任务在等待事件，也将任务从等待事件列表中移除。

- 将任务状态添加到挂起列表中。在 FreeRTOS 中有专门的列表用于记录任务的状态，记录任务挂起态的列表就是 xSuspendedTaskList，所有被挂起的任务都会放到这个列表中。

- 重置下一个任务的解除阻塞时间。重新计算一下还要多长时间执行下一个任务，如果下个任务的解锁，刚好是被挂起的那个任务，那么就是不正确的了，因为挂起的任务对调度器而言是不可见的，所以调度器是无法对挂起态的任务进行调度，所以要重新从延时列表中获取下一个要解除阻塞的任务。

- 如果挂起的是当前运行中的任务，并且调度器已经是运行的，则需要立即切换任务。不然系统的任务就错乱了，这是不允许的。

- 调度器未运行(xSchedulerRunning == pdFALSE )，但 pxCurrentTCB指向的任务刚刚被挂起，所以必须重置 pxCurrentTCB 以指向其他可以运行的任务。

- 首先调用函数 listCURRENT_LIST_LENGTH()判断一下系统中所有的任务是不是都被挂起了，也就是查看列表 xSuspendedTaskList 的长度是不是等于uxCurrentNumberOfTasks，事实上并不会发生这种情况，因为空闲任务是不允许被挂起和阻塞的，必须保证系统中无论如何都有一个任务可以运行。

- 如果没有其他任务准备就绪，因此将 pxCurrentTCB 设置为 NULL，在创建下一个任务时 pxCurrentTCB 将重新被设置。但是实际上并不会执行到这里，因为系统中的空闲任务永远是可以运行的。

- 有其他可运行的任务，则切换到其他任务。

注：任务可以调用 vTaskSuspend()这个函数来挂起任务自身，但是在挂起自身的时候会进行一次任务上下文切换，需要挂起自身就将 xTaskToSuspend 设置为 NULL 传递进来即可。无论任务是什么状态都可以被挂起，只要调用了 vTaskSuspend()这个函数就会挂起成功，不论是挂起其他任务还是挂起任务自身。

任务的挂起与恢复函数在很多时候都是很有用的，比如我们想暂停某个任务运行一段时间，但是我们又需要在其恢复的时候继续工作，那么删除任务是不可能的，因为删除了任务的话，任务的所有的信息都是不可能恢复的了，删除是完完全全删除了，里面的资源都被系统释放掉，但是挂起任务就不会这样子，调用挂起任务函数，仅仅是将任务进入挂起态，其内部的资源都会保留下来，同时也不会参与系统中任务的调度，当调用恢复函数的时候，整个任务立即从挂起态进入就绪态，并且参与任务的调度，如果该任务的优先级是当前就绪态优先级最高的任务，那么立即会按照挂起前的任务状态继续执行该任务，从而达到我们需要的效果，注意，是继续执行，也就是说，挂起任务之前是什么状态，都会被系统保留下来，在恢复的瞬间，继续执行。这个任务函数的使用方法是很简单的，只需把任务句柄传递进来即可， vTaskSuspend()会根据任务句柄的信息将对应的任务挂起，具体见代码：

```c
    if(Key_Scan(KEY1_GPIO_PORT,KEY1_GPIO_PIN) == KEY_ON)
    {
      // K1 被按下
      printf("挂起LED任务！\n");
      vTaskSuspend(LED_Task_Handle); // 挂起LED任务 
      printf("挂起LED任务成功！\n");
    } 
```





2. vTaskSuspendAll()

这个函数就是比较有意思的，将所有的任务都挂起，其实源码很简单，也很有意思，不管三七二十一将调度器锁定，并且这个函数是可以进行嵌套的，说白了挂起所有任务就是挂起任务调度器。 调度器被挂起后则不能进行上下文切换， 但是中断还是使能的。 当调度器被挂起的时候，如果有中断需要进行上下文切换， 那么这个任务将会被挂起，在调度器恢复之后才执行切换任务。 vTaskSuspendAll()源码具体见代码。调度器恢复可以调 用 xTaskResumeAll() 函数，调用了多少次 的 vTaskSuspendAll() 就要调用多少次xTaskResumeAll()进行恢复， xTaskResumeAll()的源码会在恢复任务函数中讲解。

```c
void vTaskSuspendAll(void)
{
    ++uxSchedulerSuspended;
}
```

- uxSchedulerSuspended 用于记录调度器是否被挂起，该变量默认初始值为 pdFALSE，表明调度器是没被挂起的，每调用一次 vTaskSuspendAll()函数就将变量加一，用于记录调用了多少次 vTaskSuspendAll()函数。
