# 第六章 任务管理

## 1. 任务的基本概念

系统的角度看，任务是竞争系统资源的最小运行单元。 FreeRTOS 是一个支持多任务的操作系统。在 FreeRTOS 中，任务可以使用或等待 CPU、使用内存空间等系统资源，并独立于其他任务运行，任何数量的任务可以共享同一个优先级，如果宏configUSE_TIME_SLICING 定义为 1， 处于就绪态的多个相同优先级任务将会以时间片切换的方式共享处理器。

简而言之： FreeRTOS 的任务可认为是一系列独立任务的集合。每个任务在自己的环境中运行。在任何时刻，只有一个任务得到运行， FreeRTOS 调度器决定运行哪个任务。调度器会不断的启动、停止每一个任务，宏观看上去所有的任务都在同时在执行。作为任务，不需要对调度器的活动有所了解，在任务切入切出时保存上下文环境（寄存器值、堆栈内容）是调度器主要的职责。为了实现这点，每个 FreeRTOS 任务都需要有自己的栈空间。当任务切出时，它的执行环境会被保存在该任务的栈空间中，这样当任务再次运行时，就能从堆栈中正确的恢复上次的运行环境，任务越多，需要的堆栈空间就越大，而一个系统能运行多少个任务，取决于系统的可用的 SRAM。

FreeRTOS 的可以给用户提供多个任务单独享有独立的堆栈空间，系统可以决定任务的状态，决定任务是否可以运行， 同时还能运用内核的 IPC 通信资源，实现了任务之间的通信，帮助用户管理业务程序流程。这样用户可以将更多的精力投入到业务功能的实现中。

FreeRTOS 中的任务是抢占式调度机制，高优先级的任务可打断低优先级任务，低优先级任务必须在高优先级任务阻塞或结束后才能得到调度。 同时 FreeRTOS 也支持时间片轮转调度方式，只不过时间片的调度是不允许抢占任务的 CPU 使用权。

任务通常会运行在一个死循环中，也不会退出，如果一个任务不再需要，可以调用FreeRTOS 中的任务删除 API 函数接口显式地将其删除。

## 2. 任务调度器的基本概念

FreeRTOS 中提供的任务调度器是基于优先级的全抢占式调度：在系统中除了中断处理函数、调度器上锁部分的代码和禁止中断的代码是不可抢占的之外，系统的其他部分都是可以抢占的。系统理论上可以支持无数个优先级(0 ～ N，优先级数值越小的任务优先级越低， 0 为最低优先级，分配给空闲任务使用，一般不建议用户来使用这个优先级。假如使能了 configUSE_PORT_OPTIMISED_TASK_SELECTION 这个宏（在 FreeRTOSConfig.h 文件定义）， 一般强制限定最大可用优先级数目为 32。在一些资源比较紧张的系统中， 可以根据实际情况选择只支持 8 个或 32 个优先级的系统配置。在系统中，当有比当前任务优先级更高的任务就绪时，当前任务将立刻被换出，高优先级任务抢占处理器运行。

一个操作系统如果只是具备了高优先级任务能够“立即”获得处理器并得到执行的特点，那么它仍然不算是实时操作系统。因为这个查找最高优先级任务的过程决定了调度时间是否具有确定性，例如一个包含 n 个就绪任务的系统中，如果仅仅从头找到尾，那么这个时间将直接和 n 相关，而下一个就绪任务抉择时间的长短将会极大的影响系统的实时性。

FreeRTOS 内核中采用两种方法寻找最高优先级的任务，第一种是通用的方法，在就绪链表中查找从高优先级往低查找 uxTopPriority，因为在创建任务的时候已经将优先级进行排序，查找到的第一个 uxTopPriority 就是我们需要的任务，然后通过 uxTopPriority 获取对应的任务控制块。第二种方法则是特殊方法，利用计算前导零指令CLZ，直接在 uxTopReadyPriority 这个32位变量中直接得出uxTopPriority，这样子就知道哪一个优先级任务能够运行，这种调度算法比普通方法更快捷，但受限于平台（在 STM32 中我们就使用这种方法） 。

FreeRTOS 内核中也允许创建相同优先级的任务。相同优先级的任务采用时间片轮转方式进行调度（也就是通常说的分时调度器），时间片轮转调度仅在当前系统中无更高优先级就绪任务存在的情况下才有效。为了保证系统的实时性，系统尽最大可能地保证高优先级的任务得以运行。任务调度的原则是一旦任务状态发生了改变，并且当前运行的任务优先级小于优先级队列组中任务最高优先级时，立刻进行任务切换（除非当前系统处于中断处理程序中或禁止任务切换的状态）。

## 3. 任务状态迁移

FreeRTOS 系统中的每一个任务都有多种运行状态，他们之间的转换关系是怎么样的呢？从运行态任务变成阻塞态，或者从阻塞态变成就绪态，这些任务状态是如何进行迁移？下面就让我们一起了解任务状态迁移吧

![屏幕截图 2024-10-15 122417.png](https://raw.githubusercontent.com/hazy1k/My-drawing-bed/main/2024/10/15-12-24-32-屏幕截图%202024-10-15%20122417.png)

- 创建任务→就绪态（Ready）：任务创建完成后进入就绪态，表明任务已准备就绪，随时可以运行，只等待调度器进行调度。

- 就绪态→运行态（Running）：发生任务切换时，就绪列表中最高优先级的任务被执行，从而进入运行态。

- 运行态→就绪态：有更高优先级任务创建或者恢复后，会发生任务调度，此刻就绪列表中最高优先级任务变为运行态，那么原先运行的任务由运行态变为就绪态，依然在就绪列表中，等待最高优先级的任务运行完毕继续运行原来的任务（此处可以看做是 CPU 使用权被更高优先级的任务抢占了）。

- 运行态→阻塞态（Blocked）：正在运行的任务发生阻塞（挂起、延时读信号量等待）时，该任务会从就绪列表中删除，任务状态由运行态变成阻塞态，然后发生任务切换，运行就绪列表中当前最高优先级任务。

- 阻塞态→就绪态：阻塞的任务被恢复后（任务恢复、延时时间超时、读信号量超时或读到信号量等），此时被恢复的任务会被加入就绪列表，从而由阻塞态变成就绪态；如果此时被恢复任务的优先级高于正在运行任务的优先级，则会发生任务切换，将该任务将再次转换任务状态，由就绪态变成运行态。

- 就绪态、阻塞态、运行态→挂起态（Suspended）：任务可以通过调用 vTaskSuspend() API 函数都可以将处于任何状态的任务挂起，被挂起的任务得不到CPU 的使用权，也不会参与调度，除非它从挂起态中解除。

- 挂起态→就绪态：把一个挂起状态的任务恢复的唯 一 途 径 就 是调用 vTaskResume() 或 vTaskResumeFromISR() API 函数，如果此时被恢复任务的优先级高于正在运行任务的优先级，则会发生任务切换，将该任务将再次转换任务状态，由就绪态变成运行态。

## 4. 任务状态的概念

FreeRTOS 系统中的每一任务都有多种运行状态。系统初始化完成后，创建的任务就可以在系统中竞争一定的资源，由内核进行调度。

任务状态通常分为以下四种：

- 就绪（ Ready）：该任务在就绪列表中， 就绪的任务已经具备执行的能力，只等待调度器进行调度，新创建的任务会初始化为就绪态。

- 运行（Running）：该状态表明任务正在执行， 此时它占用处理器， FreeRTOS 调度器选择运行的永远是处于最高优先级的就绪态任务，当任务被运行的一刻，它的任务状态就变成了运行态。

- 阻塞（Blocked）： 如果任务当前正在等待某个时序或外部中断，我们就说这个任务处于阻塞状态，该任务不在就绪列表中。包含任务被挂起、 任务被延时、任务正在等待信号量、读写队列或者等待读写事件等。

- 挂起态(Suspended)： 处于挂起态的任务对调度器而言是不可见的， 让一个任务进入挂起状态的唯一办法就是调用 vTaskSuspend()函数；而把一个挂起状态的任务恢复的唯一途径就是调用vTaskResume() 或 vTaskResumeFromISR()函数，我们可以这么理解挂起态与阻塞态的区别，当任务有较长的时间不允许运行的时候，我们可以挂起任务，这样子调度器就不会管这个任务的任何信息，直到我们调用恢复任务的 API 函数；而任务处于阻塞态的时候，系统还需要判断阻塞态的任务是否超时，是否可以解除阻塞。

## 5. 常用的任务函数讲解

### 5.1 任务挂起函数

1. vTaskSuspend()

挂起指定任务。被挂起的任务绝不会得到 CPU 的使用权，不管该任务具有什么优先级。

任务可以通过调用 vTaskSuspend()函数都可以将处于任何状态的任务挂起，被挂起的任务得不到 CPU 的使用权，也不会参与调度，它相对于调度器而言是不可见的，除非它从挂起态中解除。任务挂起是我们经常使用的一个函数，下面一起看看任务挂起的源码吧，

```c
#if ( INCLUDE_vTaskSuspend == 1 ) // 任务挂起函数

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
    TCB_t *pxTCB;

        taskENTER_CRITICAL();
        {
            // 如果在此处传递null，那么它正在被挂起的正在运行的任务
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
            traceTASK_SUSPEND( pxTCB );

            // 从就绪/阻塞列表中删除任务并放入挂起列表中
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
            {
                taskRESET_READY_PRIORITY( pxTCB->uxPriority );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            // 如果任务在等待事件，也从等待事件列表中移除
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
            // 将任务状态添加到挂起列表中
            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
        }
        taskEXIT_CRITICAL();

        if( xSchedulerRunning != pdFALSE )
        {
            /* 重置下一个任务的解除阻塞时间。
            重新计算一下还要多长时间执行下一个任务。
            如果下个任务的解锁，刚好是被挂起的那个任务，
            那么变量 NextTaskUnblockTime 就不对了，
            所以要重新从延时列表中获取一下。*/
            taskENTER_CRITICAL();
            {
                prvResetNextTaskUnblockTime();
            }
            taskEXIT_CRITICAL();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
        {
            if( xSchedulerRunning != pdFALSE )
            {
                // 当前的任务已经被挂起。
                configASSERT( uxSchedulerSuspended == 0 );
                // 调度器在运行时，如果这个挂起的任务是当前任务，立即切换任务。
                portYIELD_WITHIN_API();
            }
            else
            {
                /* 调度器未运行(xSchedulerRunning == pdFALSE )，
                但 pxCurrentTCB 指向的任务刚刚被暂停，
                所以必须调整 pxCurrentTCB 以指向其他任务。
                首先调用函数 listCURRENT_LIST_LENGTH()
                判断一下系统中所有的任务是不是都被挂起了，
                也就是查看列表 xSuspendedTaskList
                的长度是不是等于 uxCurrentNumberOfTasks，
                事实上并不会发生这种情况，
                因为空闲任务是不允许被挂起和阻塞的，
                必须保证系统中无论如何都有一个任务可以运行 */
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
                {
                    /* 没有其他任务准备就绪，因此将 pxCurrentTCB 设置回 NULL，
                    以便在创建下一个任务时 pxCurrentTCB 将被设置为指向它，
                    实际上并不会执行到这里*/
                    pxCurrentTCB = NULL;
                }
                else
                {
                    // 有其他任务，则切换到其他任务
                    vTaskSwitchContext();
                }
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
#endif /* INCLUDE_vTaskSuspend */
```

- 如果想要使用任务挂起函数 vTaskSuspend()则必须将宏定义INCLUDE_vTaskSuspend 配置为 1。

- xTaskToSuspend 是挂起指定任务的任务句柄， 任务必须为已创建的任务， 可以通过传递 NULL 来挂起任务自己。

- 利用任务句柄 xTaskToSuspend 来获取任务控制块，通过调用prvGetTCBFromHandle()API 函数得到对应的任务控制块。

- 从就绪/阻塞列表中删除即将要挂起的任务。然后更新"最高优先级变量 uxReadyPriorities"，目的是维护这个变量，这个变量的如下功能：
1. 在使用通用方法找到最高优先级任务时，它用来记录最高优先级任务的优先级。

2. 在使用硬件方法找到最高优先级任务时，它的每一位（共 32bit）的状态代表这个优先级上边，有没有就绪的任务
- 如果任务在等待事件，也将任务从等待事件列表中移除。

- 将任务状态添加到挂起列表中。在 FreeRTOS 中有专门的列表用于记录任务的状态，记录任务挂起态的列表就是 xSuspendedTaskList，所有被挂起的任务都会放到这个列表中。

- 重置下一个任务的解除阻塞时间。重新计算一下还要多长时间执行下一个任务，如果下个任务的解锁，刚好是被挂起的那个任务，那么就是不正确的了，因为挂起的任务对调度器而言是不可见的，所以调度器是无法对挂起态的任务进行调度，所以要重新从延时列表中获取下一个要解除阻塞的任务。

- 如果挂起的是当前运行中的任务，并且调度器已经是运行的，则需要立即切换任务。不然系统的任务就错乱了，这是不允许的。

- 调度器未运行(xSchedulerRunning == pdFALSE )，但 pxCurrentTCB指向的任务刚刚被挂起，所以必须重置 pxCurrentTCB 以指向其他可以运行的任务。

- 首先调用函数 listCURRENT_LIST_LENGTH()判断一下系统中所有的任务是不是都被挂起了，也就是查看列表 xSuspendedTaskList 的长度是不是等于uxCurrentNumberOfTasks，事实上并不会发生这种情况，因为空闲任务是不允许被挂起和阻塞的，必须保证系统中无论如何都有一个任务可以运行。

- 如果没有其他任务准备就绪，因此将 pxCurrentTCB 设置为 NULL，在创建下一个任务时 pxCurrentTCB 将重新被设置。但是实际上并不会执行到这里，因为系统中的空闲任务永远是可以运行的。

- 有其他可运行的任务，则切换到其他任务。

注：任务可以调用 vTaskSuspend()这个函数来挂起任务自身，但是在挂起自身的时候会进行一次任务上下文切换，需要挂起自身就将 xTaskToSuspend 设置为 NULL 传递进来即可。无论任务是什么状态都可以被挂起，只要调用了 vTaskSuspend()这个函数就会挂起成功，不论是挂起其他任务还是挂起任务自身。

任务的挂起与恢复函数在很多时候都是很有用的，比如我们想暂停某个任务运行一段时间，但是我们又需要在其恢复的时候继续工作，那么删除任务是不可能的，因为删除了任务的话，任务的所有的信息都是不可能恢复的了，删除是完完全全删除了，里面的资源都被系统释放掉，但是挂起任务就不会这样子，调用挂起任务函数，仅仅是将任务进入挂起态，其内部的资源都会保留下来，同时也不会参与系统中任务的调度，当调用恢复函数的时候，整个任务立即从挂起态进入就绪态，并且参与任务的调度，如果该任务的优先级是当前就绪态优先级最高的任务，那么立即会按照挂起前的任务状态继续执行该任务，从而达到我们需要的效果，注意，是继续执行，也就是说，挂起任务之前是什么状态，都会被系统保留下来，在恢复的瞬间，继续执行。这个任务函数的使用方法是很简单的，只需把任务句柄传递进来即可， vTaskSuspend()会根据任务句柄的信息将对应的任务挂起，具体见代码：

```c
    if(Key_Scan(KEY1_GPIO_PORT,KEY1_GPIO_PIN) == KEY_ON)
    {
      // K1 被按下
      printf("挂起LED任务！\n");
      vTaskSuspend(LED_Task_Handle); // 挂起LED任务 
      printf("挂起LED任务成功！\n");
    } 
```

2. vTaskSuspendAll()

这个函数就是比较有意思的，将所有的任务都挂起，其实源码很简单，也很有意思，不管三七二十一将调度器锁定，并且这个函数是可以进行嵌套的，说白了挂起所有任务就是挂起任务调度器。 调度器被挂起后则不能进行上下文切换， 但是中断还是使能的。 当调度器被挂起的时候，如果有中断需要进行上下文切换， 那么这个任务将会被挂起，在调度器恢复之后才执行切换任务。 vTaskSuspendAll()源码具体见代码。调度器恢复可以调 用 xTaskResumeAll() 函数，调用了多少次 的 vTaskSuspendAll() 就要调用多少次xTaskResumeAll()进行恢复， xTaskResumeAll()的源码会在恢复任务函数中讲解。

```c
void vTaskSuspendAll(void)
{
    ++uxSchedulerSuspended;
}
```

- uxSchedulerSuspended 用于记录调度器是否被挂起，该变量默认初始值为 pdFALSE，表明调度器是没被挂起的，每调用一次 vTaskSuspendAll()函数就将变量加一，用于记录调用了多少次 vTaskSuspendAll()函数。

### 5.2 任务恢复函数

1. vTaskResume()

既然有任务的挂起，那么当然一样有恢复，不然任务怎么恢复呢，任务恢复就是让挂起的任务重新进入就绪状态，恢复的任务会保留挂起前的状态信息，在恢复的时候根据挂起时的状态继续运行。如果被恢复任务在所有就绪态任务中， 处于最高优先级列表的第一位，那么系统将进行任务上下文的切换。下面一起看看任务恢复函数 vTaskResume()的源码

```c
#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
	// 根据 xTaskToResume 获取对应的任务控制块
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;

		// 检查要恢复的任务是否被挂起，如果没被挂起,恢复调用任务没有意义
		configASSERT( xTaskToResume );

		// 该参数不能为 NULL，同时也无法恢复当前正在执行的任务，
		// 因为当前正在运行的任务不需要恢复，只能恢复处于挂起态的任务
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
		{
			// // 进入临界区，检查任务是否还处于挂起状态
			taskENTER_CRITICAL();
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
				{
					traceTASK_RESUME( pxTCB );

					// 由于我们处于临界区，即使任务被挂起，我们也可以访问任务的状态列表。
					// 将要恢复的任务从挂起列表中删除 
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );

					// 将要恢复的任务添加到就绪列表中去
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						// 如果刚刚恢复的任务优先级比当前任务优先级更高
						// 则需要进行任务的切换
						taskYIELD_IF_USING_PREEMPTION();
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL(); // 退出临界区
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
#endif /* INCLUDE_vTaskSuspend */
```

- 如果想要使用任务恢复函数 vTaskResume()则必须将宏定义INCLUDE_vTaskSuspend 配置为 1，因为任务挂起只能通过调用 vTaskSuspend()函数进行挂起 ， 没 挂 起 的 任 务 就 无 需 恢 复 ， 当 年 需 要 调 用 vTaskSuspend() 函 数 就 必 须 使 能INCLUDE_vTaskSuspend 这个宏定义，所以想要使用 FreeRTOS 的任务挂起与恢复函数就必须将这个宏定义配置为 1。

- xTaskToResume 是恢复指定任务的任务句柄。

- 根据 xTaskToResume 任务句柄获取对应的任务控制块。

- 检查要恢复的任务是存在，如果不存在，调用恢复任务函数没有任何意义。

- pxTCB 任务控制块指针不能为 NULL，肯定要已经挂起的任务才需要恢复，同时要恢复的任务不能是当前正在运行的任务，因为当前正在运行（运行态）的任务不需要恢复，只能恢复处于挂起态的任务。

- 进入临界区，防止被打断。

- 判断要恢复的任务是否真的被挂起了，如果被挂起才需要恢复，没被挂起那当然也不需要恢复。

- 将要恢复的任务从挂起列表中删除。在 FreeRTOS 中有专门的列表用于记录任务的状态， 记录任务挂起态的列表就是 xSuspendedTaskList，现在恢复任务就将要恢复的任务从列表中删除。

- 将要恢复的任务添加到就绪列表中去，任务从挂起态恢复为就绪态 。 FreeRTOS 也 是 有 专 门 的列表记录处于就绪态的任务，这个列表就是pxReadyTasksLists。

- 如果恢复的任务优先级比当前正在运行的任务优先级更高，则需要进行任务的切换，调用 taskYIELD_IF_USING_PREEMPTION()进行一次任务切换。

- 退出临界区。

vTaskResume()函数用于恢复挂起的任务。无论任务在挂起时候调用过多少次这个vTaskSuspend()函数，也只需调用一次 vTaskResume ()函数即可将任务恢复运行，当然，无论调用多少次的 vTaskResume()函数，也只在任务是挂起态的时候才进行恢复。下面来看看任务恢复函数 vTaskResume()的使用实例，具体见代码：

```c
    if( Key_Scan(KEY2_GPIO_PORT,KEY2_GPIO_PIN) == KEY_ON)
    {
      // K2 被按下 
      printf("恢复LED任务！\n");
      vTaskResume(LED_Task_Handle); // 恢复LED任务！ 
      printf("恢复LED任务成功！\n");
    }
```

2. xTaskResumeFromISR()

xTaskResumeFromISR()与 vTaskResume()一样都是用于恢复被挂起的任务，不一样的是 xTaskResumeFromISR() 专 门 用 在 中 断 服 务 程 序 中 。 无 论 通 过 调 用 一 次 或 多 次vTaskSuspend()函数而被挂起的任务，也只需调用一次 xTaskResumeFromISR()函数即可解挂 。 要 想 使 用 该 函 数 必 须 在 FreeRTOSConfig.h 中 把 INCLUDE_vTaskSuspend 和INCLUDE_vTaskResumeFromISR 都定义为 1 才有效。任务还没有处于挂起态的时候，调用xTaskResumeFromISR()函数是没有任何意义的， xTaskResumeFromISR()源码具体见代码

```c
#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToResume );
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				// 检查可以访问的就绪列表,检查调度器是否被挂起
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					// 如果刚刚恢复的任务优先级比当前任务优先级更高，则需要进行任务的切换
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE; // 任务优先级比当前任务优先级高，需要进行任务切换
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					// 可以访问就绪列表，
					// 因此可以将任务从挂起列表删除
					// 然后添加到就绪列表中。
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
				}
				else
				{
					// 无法访问就绪列表，
					// 因此任务将被添加到待处理的就绪列表中，
					// 直到调度器被恢复再进行任务的处理。 
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
				}
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
```

- xTaskToResume 是恢复指定任务的任务句柄。

- 定义一个是否需要进行任务切换的变量 xYieldRequired，默认为pdFALSE，当任务恢复成功并且需要任务切换的话则重置为 pdTRUE，以表示需要进行任务切换。

- 根据 xTaskToResume 任务句柄获取对应的任务控制块。

- 定义一个变量 uxSavedInterruptStatus 用于保存关闭中断的状态。

- 检查要恢复的任务是存在，如果不存在，调用恢复任务函数没有任何意义。

- 调用 portSET_INTERRUPT_MASK_FROM_ISR()函数设置 basepri寄存器用于屏蔽系统可管理的中断，防止被处理被其他中断打断，当 basepri 设置为configMAX_SYSCALL_INTERRUPT_PRIORITY 的时候（该宏在 FreeRTOSConfig.h 中定义，现在配置为 5），会让系统不响应比该优先级低的中断，而优先级比之更高的中断则不受影响。就是说当这个宏定义配置为 5 的时候，中断优先级数值在 0、 1、 2、 3、 4 的这些中断是不受 FreeRTOS 管理的，不可被屏蔽，而中断优先级在 5 到 15 的中断是受到系统管理，可用被屏蔽的。

- 判断要恢复的任务是否真的被挂起了，如果被挂起才需要恢复，没被挂起那当然也不需要恢复。

- 检查可以访问的就绪列表， 检查调度器是否被挂起

- 如果刚刚恢复的任务优先级比当前任务优先级更高需要进行一次任务的切换，重置 xYieldRequired = pdTRUE 表示需要进行任务切换。

- 可以访问就绪列表，因此可以将任务从挂起列表中删除，然后添加到就绪列表中。

- 因为 uxSchedulerSuspended 调度器被挂起，无法访问就绪列表，因此任务将被添加到待处理的就绪列表中，直到调度器被恢复再进行任务的处理。

- 调用 portCLEAR_INTERRUPT_MASK_FROM_ISR()函数清除basepri 的设置，恢复屏蔽的中断。

- 返回 xYieldRequired 结果，在外部选择是否进行任务切换。

使用 xTaskResumeFromISR()的时候有几个需要注意的地方：

1. 当函数的返回值为 pdTRUE 时： 恢复运行的任务的优先级等于或高于正在运行的任务，表明在中断服务函数退出后必须进行一次上下文切换，使用portYIELD_FROM_ISR()进行上下文切换。当函数的返回值为 pdFALSE 时： 恢复运行的任务的优先级低于当前正在运行的任务，表明在中断服务函数退出后不需要进行上下文切换。

2. xTaskResumeFromISR() 通常被认为是一个危险的函数，因为它的调用并非是固定的，中断可能随时来来临。所以， xTaskResumeFromISR()不能用于任务和中断间的同步，如果中断恰巧在任务被挂起之前到达，这就会导致一次中断丢失（任务还没有挂起，调用 xTaskResumeFromISR()函数是没有意义的，只能等下一次中断）。这种情况下，可以使用信号量或者任务通知来同步就可以避免这种情况。

xTaskResumeFromISR()的使用方法具体见代码

```c
void vAnExampleISR( void )
{
    BaseType_t xYieldRequired;
    // 恢复被挂起的任务 
    xYieldRequired = xTaskResumeFromISR(xHandle);
    if(xYieldRequired == pdTRUE) 
    {
        // 执行上下文切换， ISR 返回的时候将运行另外一个任务 
        portYIELD_FROM_ISR();
    }
}
```

3. xTaskResumeAll()

之前我们讲解过 vTaskSuspendAll()函数，那么当调用了 vTaskSuspendAll()函数将调度器挂起，想要恢复调度器的时候我们就需要调用 xTaskResumeAll()函数，下面一起来看看xTaskResumeAll()的源码，具体见代码：

```c

```

## 6. 任务的设计要点

作为一个嵌入式开发人员，要对自己设计的嵌入式系统要了如指掌，任务的优先级信息，任务与中断的处理，任务的运行时间、逻辑、状态等都要知道，才能设计出好的系统，所以，在设计的时候需要根据需求制定框架。在设计之初就应该考虑下面几点因素：任务运行的上下文环境、任务的执行时间合理设计。

FreeRTOS 中程序运行的上下文包括：

- 中断服务函数

- 普通任务

- 空闲任务

任务的执行时间一般是指两个方面，一是任务从开始到结束的时间，二是任务的周期。

在系统设计的时候这两个时间候我们都需要考虑，例如，对于事件 A 对应的服务任务Ta，系统要求的实时响应指标是 10ms，而 Ta 的最大运行时间是 1ms，那么 10ms 就是任务Ta 的周期了， 1ms 则是任务的运行时间，简单来说任务 Ta 在 10ms 内完成对事件 A 的响应即可。此时，系统中还存在着以 50ms 为周期的另一任务 Tb，它每次运行的最大时间长度是 100us。在这种情况下，即使把任务 Tb 的优先级抬到比 Ta 更高的位置，对系统的实时性指标也没什么影响，因为即使在 Ta 的运行过程中， Tb 抢占了 Ta 的资源，等到 Tb 执行完毕，消耗的时间也只不过是 100us，还是在事件 A 规定的响应时间内(10ms)， Ta 能够安全完成对事件 A 的响应。但是假如系统中还存在任务 Tc，其运行时间为 20ms，假如将 Tc的优先级设置比 Ta 更高，那么在 Ta 运行的时候，突然间被 Tc 打断，等到 Tc 执行完毕，那 Ta 已经错过对事件 A（10ms）的响应了，这是不允许的。所以在我们设计的时候，必须考虑任务的时间，一般来说处理时间更短的任务优先级应设置更高一些。

## 7. 任务管理实验

任务管理实验是将任务常用的函数进行一次实验，在野火 STM32 开发板上进行该试验，通过创建两个任务，一个是 LED 任务，另一个是按键任务， LED 任务是显示任务运行的状态，而按键任务是通过检测按键的按下与否来进行对 LED 任务的挂起与恢复，具体见代码：

```c
static TaskHandle_t AppTaskCreate_Handle = NULL;// 创建任务句柄 
static TaskHandle_t LED_Task_Handle = NULL;// LED任务句柄 
static TaskHandle_t KEY_Task_Handle = NULL;// KEY任务句柄 
static void AppTaskCreate(void); // 用于创建任务
static void LED_Task(void* pvParameters);// LED_Task任务实现 
static void KEY_Task(void* pvParameters);// KEY_Task任务实现 
static void BSP_Init(void); // 用于初始化板载相关资源 

int main(void)
{	
  BaseType_t xReturn = pdPASS; // 定义一个创建信息返回值，默认为pdPASS
  // 开发板硬件初始化
  BSP_Init();
  printf("这是一个[野火]-STM32全系列开发板-FreeRTOS任务管理实验！\n\n");
  printf("按下KEY1挂起任务，按下KEY2恢复任务\n");
  // 创建AppTaskCreate任务
  xReturn = xTaskCreate((TaskFunction_t)AppTaskCreate, // 任务入口函数 
                        (const char*)"AppTaskCreate",  // 任务名字 
                        (uint16_t)512,  // 任务栈大小 
                        (void*)NULL,    // 任务入口函数参数 
                        (UBaseType_t)1, // 任务的优先级 
                        (TaskHandle_t*)&AppTaskCreate_Handle);// 任务控制块指针  
  // 启动任务调度          
  if(pdPASS == xReturn)
    vTaskStartScheduler(); // 启动任务，开启调度
  else
    return -1;  
  
  while(1);   /* 正常不会执行到这里 */    
}

// 为了方便管理，所有的任务创建函数都放在这个函数里面
static void AppTaskCreate(void)
{
  BaseType_t xReturn = pdPASS; // 定义一个创建信息返回值，默认为pdPASS
  taskENTER_CRITICAL();        // 进入临界区
  // 创建LED_Task任务
  xReturn = xTaskCreate((TaskFunction_t)LED_Task, // 任务入口函数 
                        (const char*)"LED_Task",  // 任务名字 
                        (uint16_t)512,            // 任务栈大小
                        (void*)NULL,	            // 任务入口函数参数 
                        (UBaseType_t)2,	          // 任务的优先级 
                        (TaskHandle_t*)&LED_Task_Handle);// 任务控制块指针 
  if(pdPASS == xReturn)
    printf("创建LED_Task任务成功!\r\n");
  // 创建KEY_Task任务
  xReturn = xTaskCreate((TaskFunction_t)KEY_Task, // 任务入口函数
                        (const char*)"KEY_Task",  // 任务名字 
                        (uint16_t)512,            // 任务栈大小 
                        (void*)NULL,              // 任务入口函数参数 
                        (UBaseType_t)3,           // 任务的优先级 
                        (TaskHandle_t*)&KEY_Task_Handle);// 任务控制块指针  
  if(pdPASS == xReturn)
    printf("创建KEY_Task任务成功!\r\n");
  vTaskDelete(AppTaskCreate_Handle); // 删除AppTaskCreate任务
  taskEXIT_CRITICAL();            //退出临界区
}

// LED_Task任务实现
static void LED_Task(void* parameter)
{	
  while (1)
  {
    LED1_ON;
    printf("LED_Task Running,LED1_ON\r\n");
    vTaskDelay(500);   // 延时500个tick
    LED1_OFF;     
    printf("LED_Task Running,LED1_OFF\r\n");
    vTaskDelay(500);  // 延时500个tick 
  }
}

// KEY_Task任务实现
static void KEY_Task(void* parameter)
{	
  while (1)
  {
    if(Key_Scan(KEY1_GPIO_PORT,KEY1_GPIO_PIN) == KEY_ON)
    { 
      // K1 被按下
      printf("挂起LED任务！\n");
      vTaskSuspend(LED_Task_Handle); // 挂起LED任务
      printf("挂起LED任务成功！\n");
    } 
    if(Key_Scan(KEY2_GPIO_PORT,KEY2_GPIO_PIN) == KEY_ON)
    { 
      // K2 被按下
      printf("恢复LED任务！\n");
      vTaskResume(LED_Task_Handle); // 恢复LED任务！
      printf("恢复LED任务成功！\n");
    }
    vTaskDelay(20); // 延时20个tick
  }
}

// 开发板硬件初始化
static void BSP_Init(void)
{
	NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );
	// LED 初始化 
	LED_GPIO_Config();
	// 串口初始化	
	USART_Config();
  // 按键初始化
  Key_GPIO_Config();
}
```
