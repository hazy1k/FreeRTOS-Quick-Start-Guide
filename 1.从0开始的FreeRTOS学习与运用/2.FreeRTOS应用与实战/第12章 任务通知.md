# 第十二章 任务通知

## 1. 任务通知的基本概念

FreeRTOS 从 V8.2.0 版本开始提供任务通知这个功能，每个任务都有一个 32 位的通知值，在大多数情况下，任务通知可以替代二值信号量、计数信号量、事件组， 也可以替代长度为 1 的队列（可以保存一个 32 位整数或指针值） 。

相对于以前使用 FreeRTOS 内核通信的资源，必须创建队列、二进制信号量、计数信号量或事件组的情况，使用任务通知显然更灵活。 按照 FreeRTOS 官方的说法，使用任务通知比通过信号量等 ICP 通信方式解除阻塞的任务要快 45%，并且更加省 RAM 内存空间（使用 GCC 编译器， -o2 优化级别） ，任务通知的使用无需创建队列。 想要使用任务通知，必须将 FreeRTOSConfig.h 中的宏定义 configUSE_TASK_NOTIFICATIONS 设置为 1，其实FreeRTOS 默认是为 1 的， 所以任务通知是默认使能的。

FreeRTOS 提供以下几种方式发送通知给任务 ：

- 发送通知给任务。如果有通知未读，不覆盖通知值

- 发送通知给任务。直接覆盖通知值

- 发送通知给任务，设置通知值的一个或者多个位，可用当作事件组来使用

- 发送通知给任务，递增通知值，可用当做计数量信号量使用

通过对以上任务通知方式的合理使用，可以在一定场合下替代 FreeRTOS 的信号量，队列、事件组等。

当然， 凡是都有利弊，不然的话 FreeRTOS 还要内核的 IPC 通信机制干嘛， 消息通知虽然处理更快， RAM 开销更小，但也有以下限制 ：

- 只能有一个任务介绍通知消息，因为必须指定接收通知的任务

- 只有等待通知的任务可以被阻塞，发送通知的任务，在任何情况下都不会因为发送失败而进入阻塞态

## 2. 任务通知的运作机制

顾名思义，任务通知是属于任务中附带的资源， 所以在任务被创建的时候，任务通知也被初始化的， 而在分析队列和信号量的章节中，我们知道在使用队列、信号量前，必须先创建队列和信号量，目的是为了创建队列数据结构。比如使用 xQueueCreate()函数创建队列，用 xSemaphoreCreateBinary()函数创建二值信号量等等。再来看任务通知，由于任务通知的数据结构包含在任务控制块中，只要任务存在，任务通知数据结构就已经创建完毕，可以直接使用， 所以使用的时候很是方便。

任务通知可以在任务中向指定任务发送通知，也可以在中断中向指定任务发送通知， FreeRTOS 的每个任务都有一个 32 位的通知值，任务控制块中的成员变量 ulNotifiedValue就是这个通知值。只有在任务中可以等待通知，而不允许在中断中等待通知。如果任务在等待的通知暂时无效，任务会根据用户指定的阻塞超时时间进入阻塞状态，我们可以将等待通知的任务看作是消费者；其它任务和中断可以向等待通知的任务发送通知，发送通知的任务和中断服务函数可以看作是生产者，当其他任务或者中断向这个任务发送任务通知，任务获得通知以后，该任务就会从阻塞态中解除，这与 FreeRTOS 中内核的其他通信机制一致。

## 3. 任务通知实验

### 3.1 任务通知代替消息队列

任务通知代替消息队列是在 FreeRTOS 中创建了三个任务， 其中两个任务是用于接收任务通知，另一个任务发送任务通知。三个任务独立运行，发送消息任务是通过检测按键的按下情况来发送消息通知，另两个任务获取消息通知，在任务通知中没有可用的通知之前就一直等待消息，一旦获取到消息通知就把消息打印在串口调试助手里

```c
/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
/* 其他头文件 */
#include "uart.h"
#include "led.h"
#include "key.h"
#include "limits.h"

/* 任务句柄 */
static TaskHandle_t AppTaskCreate_Handle = NULL; // 创建任务句柄

static TaskHandle_t Receive1_Task_Handle = NULL; // 接收任务1句柄
static TaskHandle_t Receive2_Task_Handle = NULL; // 接收任务2句柄
static TaskHandle_t Send_Task_Handle = NULL; // 发送任务句柄

/* 内核对象句柄 */
/* 全局变量声明 */
/* 宏定义 */
#define USE_CHAR 0 // 测试字符串的时候配置为1 测试变量的时候配置为0

/* 任务函数声明 */
static void AppTaskCreate(void); // 创建任务函数

static void Receive1_Task(void* pvParameters); // 接收任务1函数
static void Receive2_Task(void* pvParameters); // 接收任务2函数
static void Send_Task(void* pvParameters); // 发送任务函数

static void BSP_Init(void); // 板级初始化函数

// 主函数启动流程
/*
    1.BSP初始化
    2.创建APP任务
    3.启动FreeRTOS,开启调度
*/
int main(void)
{
    BaseType_t xReturn = pdPASS; // 定义一个创建信息返回值，默认为pdPASS
    BSP_Init(); // 板级初始化
    printf("这是一个FreeRTOS任务通知代替消息队列的测试程序\r\n");
    printf("按下KEY1或者KEY2向任务发送消息通知\r\n");
    // 创建AppTaskCreate任务   
    xReturn = xTaskCreate((TaskFunction_t )AppTaskCreate,
                        (const char*)"AppTaskCreate",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)1, 
                        (TaskHandle_t*)&AppTaskCreate_Handle); 
    if(xReturn == pdPASS)
    {
        vTaskStartScheduler(); // 启动FreeRTOS
    }
    else
    {
        return -1;
    }
    while(1);
}

// 为了方便管理，所有任务创建函数都在AppTaskCreate中实现
static void AppTaskCreate(void)
{
  BaseType_t xReturn = pdPASS;
  taskENTER_CRITICAL(); // 进入临界区

  xReturn = xTaskCreate((TaskFunction_t )Receive1_Task,
                        (const char*)"Receive1_Task",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)2,
                        (TaskHandle_t*)&Receive1_Task_Handle); 
  if(xReturn == pdPASS)
  {
    printf("创建接收任务1成功\r\n");
  }
  xReturn = xTaskCreate((TaskFunction_t )Receive2_Task,
                        (const char*)"Receive2_Task",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)3,
                        (TaskHandle_t*)&Receive2_Task_Handle); 
  if(xReturn == pdPASS)
  {
    printf("创建接收任务2成功\r\n");
  }
  xReturn = xTaskCreate((TaskFunction_t )Send_Task,
                        (const char*)"Send_Task",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)4,
                        (TaskHandle_t*)&Send_Task_Handle); 
  if(xReturn == pdPASS)
  {
    printf("创建发送任务成功\r\n");
  }

  vTaskDelete(AppTaskCreate_Handle);
  taskEXIT_CRITICAL(); // 退出临界区
}

// 接收任务1函数
static void Receive1_Task(void* pvParameters)
{
  BaseType_t xReturn = pdTRUE;
#if USE_CHAR
  char *r_char;
#else
  uint32_t r_num;
#endif
  while(1)
  {
    //获取任务通知 ,没获取到则一直等待
    xReturn = xTaskNotifyWait(0x0,     // 进入函数的时候不清除任务 bit
                              ULONG_MAX, // 退出函数的时候清除所有的 bit 
    #if USE_CHAR
                              (uint32_t *)&r_char, // 保存任务通知值
    #else
                              &r_num, // 保存任务通知值
    #endif
                              portMAX_DELAY); // 阻塞时间
    if(xReturn == pdTRUE)
    {
    #if USE_CHAR
      printf("Receive1_Task 任务通知为 %s \n",r_char);
    #else
      printf("Receive1_Task 任务通知为 %d \n",r_num);
    #endif
    }
    LED1_TOGGLE(); 
  }
}

// 接收任务2函数
static void Receive2_Task(void* pvParameters)
{
  BaseType_t xReturn = pdTRUE;
#if USE_CHAR
  char *r_char;
#else
  uint32_t r_num;
#endif
  while(1)
  {
    //获取任务通知 ,没获取到则一直等待
    xReturn = xTaskNotifyWait(0x0,     // 进入函数的时候不清除任务 bit
                              ULONG_MAX, // 退出函数的时候清除所有的 bit 
    #if USE_CHAR
                              (uint32_t *)&r_char, // 保存任务通知值
    #else
                              &r_num, // 保存任务通知值
    #endif
                              portMAX_DELAY); // 阻塞时间
    if(xReturn == pdTRUE)
    {
    #if USE_CHAR
      printf("Receive2_Task 任务通知为 %s \n",r_char);
    #else
      printf("Receive2_Task 任务通知为 %d \n",r_num);
    #endif
    }
    LED2_TOGGLE(); 
  }
}

// 发送任务函数
static void Send_Task(void* pvParameters)
{
  BaseType_t xReturn = pdPASS;
#if USE_CHAR
  char test_str1[] = "This is a test 1";
  char test_str2[] = "This is a test 2";
#else
  uint32_t test_num1 = 100;
  uint32_t test_num2 = 200;
#endif
  while(1)
  {
    /* KEY1被按下，向接收任务1发送通知 */
    if(Key_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == KEY_ON)
    {
      xReturn = xTaskNotify(Receive1_Task_Handle, // 通知接收任务1
      #if USE_CHAR
                            (uint32_t)&test_str1, // 通知值
      #else
                            test_num1, // 通知值
      #endif 
                            eSetValueWithOverwrite); // 覆盖当前通知
      if(xReturn == pdPASS)
      {
        printf("Receive1_Task 任务通知释放成功!\r\n");
      }                     
    }
    /* KEY2被按下，向接收任务2发送通知 */
    if(Key_Scan(KEY2_GPIO_PORT, KEY2_GPIO_PIN) == KEY_ON)
    {
      xReturn = xTaskNotify(Receive2_Task_Handle, // 通知接收任务2
      #if USE_CHAR
                            (uint32_t)&test_str2, // 通知值
      #else
                            test_num2, // 通知值
      #endif 
                            eSetValueWithOverwrite); // 覆盖当前通知
      if(xReturn == pdPASS)
      {
        printf("Receive2_Task 任务通知释放成功!\r\n");
      }
    }
    vTaskDelay(20);
  }
}

// 板级初始化函数
static void BSP_Init(void)
{
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); // 设置中断优先级分组4
    LED_Init();
    USART_Config();
    Key_GPIO_Config();
}

```

### 3.2 任务通知替代二值信号量

任务通知代替消息队列是在 FreeRTOS 中创建了三个任务，其中两个任务是用于接收任务通知，另一个任务发送任务通知。三个任务独立运行，发送通知任务是通过检测按键的按下情况来发送通知，另两个任务获取通知，在任务通知中没有可用的通知之前就一直等待任务通知，获取到通知以后就将通知值清 0，这样子是为了代替二值信号量，任务同步成功则继续执行，然后在串口调试助手里将运行信息打印出来

```c
/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
/* 其他头文件 */
#include "uart.h"
#include "led.h"
#include "key.h"

/* 任务句柄 */
static TaskHandle_t AppTaskCreate_Handle = NULL; // 创建任务句柄

static TaskHandle_t Receive1_Task_Handle = NULL; // 接收任务1句柄
static TaskHandle_t Receive2_Task_Handle = NULL; // 接收任务2句柄
static TaskHandle_t Send_Task_Handle = NULL; // 发送任务句柄

/* 内核对象句柄 */
/* 全局变量声明 */
/* 宏定义 */

/* 任务函数声明 */
static void AppTaskCreate(void); // 创建任务函数

static void Receive1_Task(void* pvParameters); // 接收任务1函数
static void Receive2_Task(void* pvParameters); // 接收任务2函数
static void Send_Task(void* pvParameters); // 发送任务函数

static void BSP_Init(void); // 板级初始化函数

// 主函数启动流程
/*
    1.BSP初始化
    2.创建APP任务
    3.启动FreeRTOS,开启调度
*/
int main(void)
{
    BaseType_t xReturn = pdPASS; // 定义一个创建信息返回值，默认为pdPASS
    BSP_Init(); // 板级初始化
    printf("这是一个FreeRTOS任务通知代替二值信号量的测试程序\r\n");
    printf("按下KEY1或者KEY2键进行任务与任务之间的同步\r\n");
    // 创建AppTaskCreate任务   
    xReturn = xTaskCreate((TaskFunction_t )AppTaskCreate,
                        (const char*)"AppTaskCreate",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)1, 
                        (TaskHandle_t*)&AppTaskCreate_Handle); 
    if(xReturn == pdPASS)
    {
        vTaskStartScheduler(); // 启动FreeRTOS
    }
    else
    {
        return -1;
    }
    while(1);
}

// 为了方便管理，所有任务创建函数都在AppTaskCreate中实现
static void AppTaskCreate(void)
{
  BaseType_t xReturn = pdPASS;
  taskENTER_CRITICAL(); // 进入临界区

  xReturn = xTaskCreate((TaskFunction_t )Receive1_Task,
                        (const char*)"Receive1_Task",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)2,
                        (TaskHandle_t*)&Receive1_Task_Handle); 
  if(xReturn == pdPASS)
  {
    printf("创建接收任务1成功\r\n");
  }
  xReturn = xTaskCreate((TaskFunction_t )Receive2_Task,
                        (const char*)"Receive2_Task",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)3,
                        (TaskHandle_t*)&Receive2_Task_Handle); 
  if(xReturn == pdPASS)
  {
    printf("创建接收任务2成功\r\n");
  }
  xReturn = xTaskCreate((TaskFunction_t )Send_Task,
                        (const char*)"Send_Task",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)4,
                        (TaskHandle_t*)&Send_Task_Handle); 
  if(xReturn == pdPASS)
  {
    printf("创建发送任务成功\r\n");
  }

  vTaskDelete(AppTaskCreate_Handle);
  taskEXIT_CRITICAL(); // 退出临界区
}

// 接收任务1函数
static void Receive1_Task(void* pvParameters)
{
  while(1)
  {
    ulTaskNotifyTake(pdTRUE, portMAX_DELAY); // 等待通知
    printf("接收任务1收到通知\r\n");
    LED1_TOGGLE();
  }
}

// 接收任务2函数
static void Receive2_Task(void* pvParameters)
{
  while(1)
  {
    ulTaskNotifyTake(pdTRUE, portMAX_DELAY); // 等待通知
    printf("接收任务2收到通知\r\n");
    LED2_TOGGLE();
  }
}

static void Send_Task(void* pvParameters)
{
  BaseType_t xReturn = pdPASS;
  while(1)
  {
    if(Key_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == KEY_ON)
    {
      xReturn = xTaskNotifyGive(Receive1_Task_Handle); // 发送通知给接收任务1
      if(xReturn == pdPASS)
      {
        printf("发送任务给接收任务1成功\r\n");
      }
    }
    if(Key_Scan(KEY2_GPIO_PORT, KEY2_GPIO_PIN) == KEY_ON)
    {
      xReturn = xTaskNotifyGive(Receive2_Task_Handle); // 发送通知给接收任务2
      if(xReturn == pdPASS)
      {
        printf("发送任务给接收任务2成功\r\n");
      }
    }
    vTaskDelay(20);
  }
}

// 板级初始化函数
static void BSP_Init(void)
{
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); // 设置中断优先级分组4
    LED_Init();
    USART_Config();
    Key_GPIO_Config();
}

```
