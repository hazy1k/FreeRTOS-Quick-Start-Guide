# 第九章 互斥量

## 1. 互斥量基本概念

互斥量又称互斥信号量（本质是信号量），是一种特殊的二值信号量，它和信号量不同的是，它支持互斥量所有权、递归访问以及防止优先级翻转的特性，用于实现对临界资源的独占式处理。任意时刻互斥量的状态只有两种，开锁或闭锁。当互斥量被任务持有时，该互斥量处于闭锁状态，这个任务获得互斥量的所有权。当该任务释放这个互斥量时，该互斥量处于开锁状态， 任务失去该互斥量的所有权。当一个任务持有互斥量时，其他任务将不能再对该互斥量进行开锁或持有。 持有该互斥量的任务也能够再次获得这个锁而不被挂起，这就是递归访问，也就是递归互斥量的特性，这个特性与一般的信号量有很大的不同，在信号量中，由于已经不存在可用的信号量， 任务递归获取信号量时会发生主动挂起任务最终形成死锁。

如果想要用于实现同步（任务之间或者任务与中断之间），二值信号量或许是更好的选择，虽然互斥量也可以用于任务与任务、 任务与中断的同步，但是互斥量更多的是用于保护资源的互锁。

用于互锁的互斥量可以充当保护资源的令牌， 当一个任务希望访问某个资源时，它必须先获取令牌。当任务使用完资源后，必须还回令牌，以便其它任务可以访问该资源。是不是很熟悉，在我们的二值信号量里面也是一样的，用于保护临界资源，保证多任务的访问井然有序。当任务获取到信号量的时候才能开始使用被保护的资源，使用完就释放信号量，下一个任务才能获取到信号量从而可用使用被保护的资源。但是信号量会导致的另一个潜在问题，那就是任务优先级翻转（具体会在下文讲解） 。 而 FreeRTOS 提供的互斥量可以通过优先级继承算法， 可以降低优先级翻转问题产生的影响，所以，用于临界资源的保护一般建议使用互斥量。

## 2. 互斥量的优先级继承机制

在 FreeRTOS 操作系统中为了降低优先级翻转问题利用了优先级继承算法。优先级继承算法是指，暂时提高某个占有某种资源的低优先级任务的优先级，使之与在所有等待该资源的任务中优先级最高那个任务的优先级相等，而当这个低优先级任务执行完毕释放该资源时，优先级重新回到初始设定值。因此，继承优先级的任务避免了系统资源被任何中间优先级的任务抢占。

互斥量与二值信号量最大的不同是：互斥量具有优先级继承机制，而信号量没有。也就是说，某个临界资源受到一个互斥量保护，如果这个资源正在被一个低优先级任务使用，那么此时的互斥量是闭锁状态，也代表了没有任务能申请到这个互斥量，如果此时一个高优先级任务想要对这个资源进行访问，去申请这个互斥量，那么高优先级任务会因为申请不到互斥量而进入阻塞态，那么系统会将现在持有该互斥量的任务的优先级临时提升到与高优先级任务的优先级相同，这个优先级提升的过程叫做优先级继承。这个优先级继承机制确保高优先级任务进入阻塞状态的时间尽可能短，以及将已经出现的“优先级翻转”危害降低到最小。

没有理解？没问题，结合过程示意图再说一遍。我们知道任务的优先级在创建的时候就已经是设置好的，高优先级的任务可以打断低优先级的任务，抢占 CPU 的使用权。但是在很多场合中，某些资源只有一个，当低优先级任务正在占用该资源的时候，即便高优先级任务也只能乖乖的等待低优先级任务使用完该资源后释放资源。这里高优先级任务无法运行而低优先级任务可以运行的现象称为“优先级翻转”。

为什么说优先级翻转在操作系统中是危害很大？因为在我们一开始创造这个系统的时候，我们就已经设置好了任务的优先级了，越重要的任务优先级越高。但是发生优先级翻转，对我们操作系统是致命的危害，会导致系统的高优先级任务阻塞时间过长。

举个例子，现在有 3 个任务分别为 H 任务（High）、 M 任务（Middle）、 L 任务（Low）， 3 个任务的优先级顺序为 H 任务>M 任务>L 任务。正常运行的时候 H 任务可以打断 M 任务与 L 任务， M 任务可以打断 L 任务，假设系统中有一个资源被保护了，此时该资源被 L 任务正在使用中，某一刻， H 任务需要使用该资源，但是 L 任务还没使用完， H任务则因为申请不到资源而进入阻塞态， L 任务继续使用该资源，此时已经出现了“优先级翻转”现象，高优先级任务在等着低优先级的任务执行，如果在 L 任务执行的时候刚好M 任务被唤醒了，由于 M 任务优先级比 L 任务优先级高，那么会打断 L 任务，抢占了CPU 的使用权，直到 M 任务执行完，再把 CUP 使用权归还给 L 任务， L 任务继续执行，等到执行完毕之后释放该资源， H 任务此时才从阻塞态解除，使用该资源。这个过程，本来是最高优先级的 H 任务，在等待了更低优先级的 L 任务与 M 任务，其阻塞的时间是 M任务运行时间+L 任务运行时间，这只是只有 3 个任务的系统，假如很多个这样子的任务打断最低优先级的任务，那这个系统最高优先级任务岂不是崩溃了，这个现象是绝对不允许出现的，高优先级的任务必须能及时响应。所以，没有优先级继承的情况下，使用资源保

护，其危害极大。

## 3. 互斥量应用场景

互斥量的使用比较单一，因为它是信号量的一种，并且它是以锁的形式存在。在初始化的时候，互斥量处于开锁的状态，而被任务持有的时候则立刻转为闭锁的状态。互斥量更适合于：

- 可能会引起优先级翻转的情况

递归互斥量更适用于：

- 任务可能会多次获取互斥量的情况下。这样可以避免同一任务多次递归持有而造成死锁的问题。

多任务环境下往往存在多个任务竞争同一临界资源的应用场景，互斥量可被用于对临界资源的保护从而实现独占式访问。另外，互斥量可以降低信号量存在的优先级翻转问题带来的影响。

比如有两个任务需要对串口进行发送数据，其硬件资源只有一个，那么两个任务肯定不能同时发送啦，不然导致数据错误，那么，就可以用互斥量对串口资源进行保护，当一个任务正在使用串口的时候，另一个任务则无法使用串口，等到任务使用串口完毕之后，另外一个任务才能获得串口的使用权。

另外需要注意的是互斥量不能在中断服务函数中使用，因为其特有的优先级继承机制只在任务起作用，在中断的上下文环境毫无意义。

## 4. 互斥量运作机制

多任务环境下会存在多个任务访问同一临界资源的场景，该资源会被任务独占处理。其他任务在资源被占用的情况下不允许对该临界资源进行访问，这个时候就需要用到FreeRTOS 的互斥量来进行资源保护，那么互斥量是怎样来避免这种冲突？

用互斥量处理不同任务对临界资源的同步访问时， 任务想要获得互斥量才能进行资源访问，如果一旦有任务成功获得了互斥量，则互斥量立即变为闭锁状态，此时其他任务会因为获取不到互斥量而不能访问这个资源， 任务会根据用户自定义的等待时间进行等待，直到互斥量被持有的任务释放后，其他任务才能获取互斥量从而得以访问该临界资源，此时互斥量再次上锁，如此一来就可以确保每个时刻只有一个任务正在访问这个临界资源，保证了临界资源操作的安全性。

![屏幕截图 2025-03-06 185645.png](https://raw.githubusercontent.com/hazy1k/My-drawing-bed/main/2025/03/06-18-56-55-屏幕截图%202025-03-06%20185645.png)

## 5. 互斥量实验

### 5.1 模拟优先级翻转

模拟优先级翻转实验是在 FreeRTOS 中创建了三个任务与一个二值信号量， 任务分别是高优先级任务，中优先级任务，低优先级任务， 用于模拟产生优先级翻转。 低优先级任务在获取信号量的时候，被中优先级打断，中优先级的任务执行时间较长，因为低优先级还未释放信号量，那么高优先级任务就无法取得信号量继续运行，此时就发生了优先级翻转，任务在运行中，使用串口打印出相关信息

```c
/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h" 
#include "semphr.h"
/* 其他头文件 */
#include "uart.h"
#include "led.h"
#include "key.h"

/* 任务句柄 */
static TaskHandle_t AppTaskCreate_Handle = NULL; // 创建任务句柄

static TaskHandle_t LowPriority_Task_Handle = NULL; // 低优先级任务句柄
static TaskHandle_t MidPriority_Task_Handle = NULL; // 中优先级任务句柄
static TaskHandle_t HighPriority_Task_Handle = NULL; // 高优先级任务句柄

/* 内核对象句柄 */
SemaphoreHandle_t BinarySem_Handle = NULL; // 二值信号量句柄
/* 全局变量声明 */
/* 宏定义 */


/* 任务函数声明 */
static void AppTaskCreate(void); // 创建任务函数

static void LowPriority_Task(void* pvParameters); // 低优先级任务函数
static void MidPriority_Task(void* pvParameters); // 中优先级任务函数
static void HighPriority_Task(void* pvParameters); // 高优先级任务函数

static void BSP_Init(void); // 板级初始化函数

// 主函数启动流程
/*
    1.BSP初始化
    2.创建APP任务
    3.启动FreeRTOS,开启调度
*/
int main(void)
{
    BaseType_t xReturn = pdPASS; // 定义一个创建信息返回值，默认为pdPASS
    BSP_Init(); // 板级初始化
    printf("FreeRTOS 优先级翻转实验\r\n");
    // 创建AppTaskCreate任务   
    xReturn = xTaskCreate((TaskFunction_t )AppTaskCreate,
                        (const char*)"AppTaskCreate",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)1, 
                        (TaskHandle_t*)&AppTaskCreate_Handle); 
    if(xReturn == pdPASS)
    {
        vTaskStartScheduler(); // 启动FreeRTOS
    }
    else
    {
        return -1;
    }
    while(1);
}

// 为了方便管理，所有任务创建函数都在AppTaskCreate中实现
static void AppTaskCreate(void)
{
  BaseType_t xReturn = pdPASS;
  taskENTER_CRITICAL(); // 进入临界区

  BinarySem_Handle = xSemaphoreCreateBinary(); // 创建二值信号量
  if(BinarySem_Handle != NULL)
  {
    printf("二值信号量创建成功！\r\n");
  }
  xReturn = xSemaphoreGive(BinarySem_Handle); // 释放二值信号量

  // 创建低优先级任务
  xReturn = xTaskCreate((TaskFunction_t )LowPriority_Task,
                        (const char*)"LowPriority_Task",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)2, 
                        (TaskHandle_t*)&LowPriority_Task_Handle); 
  if(xReturn == pdPASS)
  {
      printf("低优先级任务创建成功！\r\n");
  }
  else
  {
    printf("低优先级任务创建失败！\r\n");
  }

  // 创建中优先级任务
  xReturn = xTaskCreate((TaskFunction_t )MidPriority_Task,
                        (const char*)"MidPriority_Task",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)3, 
                        (TaskHandle_t*)&MidPriority_Task_Handle); 
  if(xReturn == pdPASS)
  {
    printf("中优先级任务创建成功！\r\n");
  }
  else
  {
    printf("中优先级任务创建失败！\r\n");
  }

  // 创建高优先级任务
  xReturn = xTaskCreate((TaskFunction_t )HighPriority_Task,
                        (const char*)"HighPriority_Task",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)4, 
                        (TaskHandle_t*)&HighPriority_Task_Handle); 
  if(xReturn == pdPASS)
  {
    printf("高优先级任务创建成功！\r\n");
  }
  else
  {
    printf("高优先级任务创建失败！\r\n");
  }
  vTaskDelete(AppTaskCreate_Handle);
  taskEXIT_CRITICAL(); // 退出临界区
}

// 低优先级任务函数
static void LowPriority_Task(void* pvParameters)
{
  static uint32_t i;
  BaseType_t xReturn = pdPASS;
  while(1)
  {
    printf("低优先级获取信号量中...\r\n");
    xReturn = xSemaphoreTake(BinarySem_Handle, portMAX_DELAY); // 低优先级任务获取信号量
    if(xReturn == pdTRUE)
    {
      printf("低优先级获取信号量成功！\r\n");
    }
    for(i = 0; i < 1000000; i++) // 模拟低优先级任务长时间占用信号量
    {
      taskYIELD(); // 任务调度
    }
    printf("低优先级释放信号量\r\n");
    xReturn = xSemaphoreGive(BinarySem_Handle); // 低优先级任务释放信号量
    LED1_TOGGLE();
    vTaskDelay(500);
  }
}

// 中优先级任务函数
static void MidPriority_Task(void* pvParameters)
{
  while(1)
  {
    printf("中优先级任务运行中...\r\n");
    vTaskDelay(500);
  }
}

// 高优先级任务函数
static void HighPriority_Task(void* pvParameters)
{
  BaseType_t xReturn = pdTRUE;
  while(1)
  {
    printf("高优先级申请获取信号量\r\n");
    xReturn = xSemaphoreTake(BinarySem_Handle, portMAX_DELAY); // 高优先级任务申请获取信号量
    if(xReturn == pdTRUE)
    {
      printf("高优先级获取信号量成功！\r\n");
    }
    LED1_TOGGLE();
    xReturn = xSemaphoreGive(BinarySem_Handle); // 高优先级任务释放信号量
    vTaskDelay(500);
  }
}

// 板级初始化函数
static void BSP_Init(void)
{
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); // 设置中断优先级分组4
    LED_Init();
    USART_Config();
    Key_GPIO_Config();
}
```

### 5.2 互斥量

互斥量实验是基于优先级翻转实验进行修改的，目的是为了测试互斥量的优先级继承机制是否有效

```c

```
