# 第三章 数据结构-列表与列表项讲解

在 FreeRTOS 中存在着大量的基础数据结构列表和列表项的操作，要想读懂 FreeRTOS的源码或者从 0 到 1 开始实现 FreeRTOS，就必须弄懂列表和列表项的操作，其实也没那么难。

列表和列表项是直接从 FreeRTOS 源码的注释中的 list 和 list item 翻译过来的，其实就是对应我们 C 语言当中的链表和节点，在后续的讲解中，我们说的链表就是列表，节点就是列表项。

## 1. C语言链表简介

链表作为 C 语言中一种基础的数据结构，在平时写程序的时候用的并不多，但在操作系统里面使用的非常多。链表就好比一个圆形的晾衣架，晾衣架上面有很多钩子，钩子首尾相连。链表也是，链表由节点组成，节点与节点之间首尾相连。

晾衣架的钩子本身不能代表很多东西，但是钩子本身却可以挂很多东西。同样，链表也类似，链表的节点本身不能存储太多东西，或者说链表的节点本来就不是用来存储大量数据的，但是节点跟晾衣架的钩子一样，可以挂很多数据。

![屏幕截图 2024 10 04 111327](https://img.picgo.net/2024/10/04/-2024-10-04-1113277ff6b72bb82b4708.png)

链表分为单向链表和双向链表，单向链表很少用，使用最多的还是双向链表。

### 1.1 单向链表

#### 1.1.1 链表的定义

单向链表示具体见图。该链表中共有 n 个节点， 前一个节点都有一个箭头指向后一个节点，首尾相连，组成一个圈。

![屏幕截图 2024 10 04 111427](https://img.picgo.net/2024/10/04/-2024-10-04-1114278527739de007b004.png)

节点本身必须包含一个节点指针，用于指向后一个节点，除了这个节点指针是必须有的之外，节点本身还可以携带一些私有信息，怎么携带？

节点都是一个自定义类型的数据结构，在这个数据结构里面可以有单个的数据、数组、指针数据和自定义的结构体数据类型等等信息

```c
struct node
{
    struct node *next; // 指向链表的下一个节点
    char datal; // 单个的数据
    unsigned char array[]; // 数组
    unsigned long *prt; // 指针数据
    struct userstruct data2; // 自定义结构体类型数据
}
```

除了 struct node *next 这个节点指针之外，剩下的成员都可以理解为节点携带的数据，但是这种方法很少用。 通常的做法是节点里面只包含一个用于指向下一个节点的指针。要通过链表存储的数据内嵌一个节点即可，这些要存储的数据通过这个内嵌的节点即可挂接到链表中，就好像晾衣架的钩子一样，把衣服挂接到晾衣架中。

```c
// 节点定义 
struct node
{
    struct node *next; // 指向链表的下一个节点 
}

struct userstruct
{
    // 在结构体中，内嵌一个节点指针，通过这个节点将数据挂接到链表 
    struct node *next;
    /* 各种各样......，要存储的数据 */
}
```

![屏幕截图 2024 10 04 111942](https://img.picgo.net/2024/10/04/-2024-10-04-11194243147034d06bd826.png)

#### 1.1.2 链表的操作

链表最大的作用是通过节点把离散的数据链接在一起， 组成一个表，这大概就是链表的字面解释了吧。 链表常规的操作就是节点的插入和删除，为了顺利的插入，通常一条链表我们会人为地规定一个根节点， 这个根节点称为生产者。 通常根节点还会有一个节点计数器，用于统计整条链表的节点个数。

![屏幕截图 2024 10 04 112055](https://img.picgo.net/2024/10/04/-2024-10-04-11205520bc16297955a207.png)

有关链表节点的删除和操作的代码讲解这里先略过，具体的可参考本章接下来的“FreeRTO 中链表的实现”小节，在这个小节里面会有非常详细的讲解，这里我们先建立概念为主。

### 1.2 双向链表

双向链表与单向链表的区别就是节点中有两个节点指针，分别指向前后两个节点，其它完全一样。有关双向链表的文字描述参考单向链表小节即可， 有关双向链表的示意图：

![屏幕截图 2024 10 04 112157](https://img.picgo.net/2024/10/04/-2024-10-04-11215742e5fe7720365808.png)

## 2. FreeRTOS中链表的实现

### 2.1 实现链表节点

#### 2.1.1 定义链表节点数据结构

链表节点的数据结构在 list.h 中定义：

```c
struct xLIST_ITEM
{
    TickType_t xItemValue;         // 辅助值，用于帮助节点做顺序排列 
    struct xLIST_ITEM *pxNext;     // 指向链表下一个节点 
    struct xLIST_ITEM *pxPrevious; // 指向链表前一个节点 
    void *pvOwner;                 // 指向拥有该节点的内核对象，通常是 TCB 
    void *pvContainer;             // 指向该节点所在的链表 
};
typedef struct xLIST_ITEM ListItem_t;//节点数据类型重定义 
```

![屏幕截图 2024 10 04 112438](https://img.picgo.net/2024/10/04/-2024-10-04-112438f6a61693b2662b65.png)

在 FreeRTOS 中，凡是涉及到数据类型的地方， FreeRTOS 都会将标准的 C 数据类型用 typedef 重新取一个类型名。这些经过重定义的数据类型放在 portmacro.h。

除了 TickType_t 外，其它数据类型重定义是本章后面内容需要使用到，这里统一贴出来，后面将不再赘述。

```c
#ifndef PORTMACRO_H
#define PORTMACRO_H

#include "stdint.h"
#include "stddef.h"

// 数据类型重定义 
#define portCHAR char
#define portFLOAT float
#define portDOUBLE double
#define portLONG long
#define portSHORT short
#define portSTACK_TYPE uint32_t
#define portBASE_TYPE long

typedef portSTACK_TYPE StackType_t;
typedef long BaseType_t;
typedef unsigned long UBaseType_t;

#if(configUSE_16_BIT_TICKS == 1)
typedef uint16_t TickType_t;
#define portMAX_DELAY (TickType_t)0xffff
#else
typedef uint32_t TickType_t;
#define portMAX_DELAY (TickType_t)0xffffffffUL
#endif

#endif /* PORTMACRO_H */
```

TickType_t 具体表示 16 位还是 32 位，由configUSE_16_BIT_TICKS 这个宏决定， 当该宏定义为 1 时， TickType_t 为 16 位，否则为32 位。

该宏在 FreeRTOSConfig.h中默认定义为 0， 所以 TickType_t 表示 32 位。

```c
#ifndef FREERTOS_CONFIG_H
#define FREERTOS_CONFIG_H

#define configUSE_16_BIT_TICKS 0

#endif /* FREERTOS_CONFIG_H */
```

#### 2.1.2 链表节点初始化

链表节点初始化函数在 list.c 中实现

```c
void vListInitialiseItem(ListItem_t *const pxItem)
{
    // 初始化该节点所在的链表为空，表示节点还没有插入任何链表
    pxItem->pvContainer = NULL;
}
```

链表节点 ListItem_t 总共有 5 个成员，但是初始化的时候只需将 pvContainer 初始化为空即可， 表示该节点还没有插入到任何链表。一个初始化好的节点示意图具体见图：

![屏幕截图 2024 10 04 143549](https://img.picgo.net/2024/10/04/-2024-10-04-143549a7291fa0d198e77b.png)

### 2.2 实现链表根节点

#### 2.2.1 定义链表根节点数据结构

链表根节点的数据结构在 list.h 中定义

```c
typedef struct xLIST
{
    UBaseType_t uxNumberOfItems; // 链表节点计数器
    ListItem_t *pxIndex; // 链表节点索引指针
    MiniListItem_t xListEnd; // 链表最后一个节点
}List_t;
```

![屏幕截图 2024 10 04 143846](https://img.picgo.net/2024/10/04/-2024-10-04-14384668757dd1f9a01ffa.png)

链表最后一个节点。我们知道，链表是首尾相连的，是一个圈，首就是尾，尾就是首，这里从字面上理解就是链表的最后一个节点，实际也就是链表的第一个节点，我们称之为生产者。该生产者的数据类型是一个精简的节点， 也在 list.h 中定义，具体实现见。

```c
struct xMINI_LIST_ITEM
{
    TickType_t xItemValue; // 辅助值，用于帮助节点做升序排列 
    struct xLIST_ITEM *pxNext; // 指向链表下一个节点 
    struct xLIST_ITEM *pxPrevious; // 指向链表前一个节点 
};
typedef struct xMINI_LIST_ITEM MiniListItem_t; // 精简节点数据类型重定义 
```

#### 2.2.2 链表根节点初始化

链表节点初始化函数在 list.c 中实现

```c
void vListInitialise(List_t *const pxList)
{
    // 将链表索引指针指向最后一个节点 
    pxList->pxIndex = (ListItem_t*) &(pxList->xListEnd);
    // 将链表最后一个节点的辅助排序的值设置为最大，确保该节点就是链表的最后节点
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    // 将最后一个节点的 pxNext 和 pxPrevious 指针均指向节点自身，表示链表为空 
    pxList->xListEnd.pxNext = (ListItem_t*) &(pxList->xListEnd);
    pxList->xListEnd.pxPrevious = (ListItem_t*) &(pxList->xListEnd);
    // 初始化链表节点计数器的值为 0，表示链表为空
    pxList->uxNumberOfItems = (UBaseType_t)0U;
}
```

![屏幕截图 2024 10 04 145118](https://img.picgo.net/2024/10/04/-2024-10-04-14511894683804e292bbd1.png)

#### 2.2.3 将节点插入到链表的尾部

将节点插入到链表的尾部（可以理解为头部） 就是将一个新的节点插入到一个空的链表

```c
void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
    ListItem_t *const pxIndex = pxList->pxIndex;
    pxNewListItem->pxNext = pxIndex; 
    pxNewListItem->pxPrevious = pxIndex->pxPrevious; 
    pxIndex->pxPrevious->pxNext = pxNewListItem; 
    pxIndex->pxPrevious = pxNewListItem; 

    // 记住该节点所在的链表 
    pxNewListItem->pvContainer = (void*)pxList; 

    // 链表节点计数器++ 
    (pxList->uxNumberOfItems)++; 
}
```

![屏幕截图 2024 10 04 145417](https://img.picgo.net/2024/10/04/-2024-10-04-1454179d3a6e1093f8c643.png)

#### 2.2.4 将节点按照升序排列插入到链表

将节点按照升序排列插入到链表，如果有两个节点的值相同，则新节点在旧节点的后面插入

```c
void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
    ListItem_t *pxIterator;
    // 获取节点的排序辅助值 
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue; 
    // 寻找节点要插入的位置
    if(xValueOfInsertion == portMAX_DELAY)
    {
         pxIterator = pxList->xListEnd.pxPrevious;
    }
    else
    {
        for(pxIterator = (ListItem_t*) &(pxList->xListEnd);
            pxIterator->pxNext->xItemValue <= xValueOfInsertion;
            pxIterator = pxIterator->pxNext)
        {
        // 没有事情可做，不断迭代只为了找到节点要插入的位置 
        }
    }
    // 根据升序排列，将节点插入
    pxNewListItem->pxNext = pxIterator->pxNext; 
    pxNewListItem->pxNext->pxPrevious = pxNewListItem; 
    pxNewListItem->pxPrevious = pxIterator; 
    pxIterator->pxNext = pxNewListItem; 

    // 记住该节点所在的链表 
    pxNewListItem->pvContainer = ( void * ) pxList; 

    // 链表节点计数器++ 
    (pxList->uxNumberOfItems)++; 
}
```

![屏幕截图 2024 10 04 150045](https://img.picgo.net/2024/10/04/-2024-10-04-150045f7c7eaf7baae0674.png)

#### 2.2.5 将节点从链表删除

```c
UBaseType_t uxListRemove(ListItem_t *const pxItemToRemove)
{
    // 获取节点所在的链表 
    List_t *const pxList = (List_t*)pxItemToRemove->pvContainer;
    // 将指定的节点从链表删除
    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious; 
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext; 
    // 调整链表的节点索引指针
    if(pxList->pxIndex == pxItemToRemove)
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    }
    // 初始化该节点所在的链表为空，表示节点还没有插入任何链表 
    pxItemToRemove->pvContainer = NULL; 
    // 链表节点计数器-- 
    ( pxList->uxNumberOfItems )--; 
    // 返回链表中剩余节点的个数 
    return pxList->uxNumberOfItems;
}
```

假设将一个有三个节点的链表中的中间节点节点删除，删除操作的过程示意图具体可见图:

![屏幕截图 2024 10 04 150409](https://img.picgo.net/2024/10/04/-2024-10-04-150409d2bba1e3c5f8ff4d.png)

#### 2.2.6 节点带参宏小函数

在 list.h 中，还定义了各种各样的带参宏，方便对节点做一些简单的操作：

```c
// 初始化节点的拥有者 
#define listSET_LIST_ITEM_OWNER(pxListItem, pxOwner)\
((pxListItem )->pvOwner = (void*)(pxOwner))

// 获取节点拥有者 
#define listGET_LIST_ITEM_OWNER(pxListItem)\
((pxListItem)->pvOwner)

// 初始化节点排序辅助值 
#define listSET_LIST_ITEM_VALUE(pxListItem, xValue)\
((pxListItem)->xItemValue = (xValue))

// 获取节点排序辅助值 
#define listGET_LIST_ITEM_VALUE(pxListItem )\
((pxListItem)->xItemValue)

// 获取链表根节点的节点计数器的值 
#define listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxList)\
(((pxList)->xListEnd).pxNext->xItemValue)

// 获取链表的入口节点
#define listGET_HEAD_ENTRY(pxList)\
(((pxList)->xListEnd).pxNext)

// 获取节点的下一个节点
#define listGET_NEXT(pxListItem)\
((pxListItem)->pxNext)

// 获取链表的最后一个节点 
#define listGET_END_MARKER(pxList)\
((ListItem_t const*)(&((pxList)->xListEnd)))

// 判断链表是否为空 
#define listLIST_IS_EMPTY(pxList)\
((BaseType_t) ((pxList)->uxNumberOfItems == (UBaseType_t)0))

// 获取链表的节点数 
#define listCURRENT_LIST_LENGTH(pxList)\
((pxList)->uxNumberOfItems)

// 获取链表第一个节点的 OWNER，即 TCB 
#define listGET_OWNER_OF_NEXT_ENTRY(pxTCB, pxList)
{
    List_t *const pxConstList = (pxList);
    /* 节点索引指向链表第一个节点 */ \
    (pxConstList)->pxIndex = (pxConstList)->pxIndex->pxNext;
    /* 这个操作有啥用？ */ \
    if((void*)(pxConstList)->pxIndex == (void*)&((pxConstList)->xListEnd)) \
    {
        (pxConstList)->pxIndex = (pxConstList)->pxIndex->pxNext;
    }
    /* 获取节点的 OWNER，即 TCB */ \
    (pxTCB) = (pxConstList)->pxIndex->pvOwner;
}
```
