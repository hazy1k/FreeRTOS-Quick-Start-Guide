# 第二章 裸机系统与多任务系统

## 1. 裸机系统

裸机系统通常分成轮询系统和前后台系统，有关这两者的具体实现方式请看下面的讲解

### 1.1 轮询系统

轮询系统即是在裸机编程的时候，先初始化好相关的硬件，然后让主程序在一个死循环里面不断循环，顺序地做各种事情，轮询系统是一种非常简单的软件结构，通常只适用于那些只需要顺序执行代码且不需要外部事件来驱动的就能完成的事情。但是，如果加入了按键操作等需要检测外部信号的事件，用来模拟紧急报警，那么整个系统的实时响应能力就不会那么好了。

```c
int main()
{
    // 硬件相关初始化
    HardWareInit();
    // 无限循环
    while(1)
    {
        // 事件1
        DoSomething1();
        // 事件2
        DoSomething2();
        // 事件3
        DoSomething3();
    }
}
```

假设DoSomething3 是按键扫描，当外部按键被按下，相当于一个警报，这个时候，需要立马响应，并做紧急处理，而这个时候程序刚好执行到 DoSomething1，要命的是 DoSomethingg1需要执行的时间比较久，久到按键释放之后都没有执行完毕，那么当执行到 DoSomething3的时候就会丢失掉一次事件。足见，轮询系统只适合顺序执行的功能代码，当有外部事件驱动时，实时性就会降低。

### 1.2 前后台系统

相比轮询系统，前后台系统是在轮询系统的基础上加入了中断。外部事件的响应在中断里面完成，事件的处理还是回到轮询系统中完成，中断在这里我们称为前台， main 函数里面的无限循环我们称为后台

```c
int flag1 = 0;
int flag2 = 0;
int flag3 = 0;

int main(void)
{
    // 硬件相关初始化
    HardWareInit();
    // 无限循环
    for (;;) 
    {
        if(flag1) 
        {
            // 处理事情 1
            DoSomething1();
        }
        if(flag2) 
        {
            // 处理事情 2
            DoSomething2();
        }
        if(flag3) 
        {
            // 处理事情 3 
            DoSomething3();
        }
    }
}

void ISR1(void)
{
    // 置位标志位
    flag1 = 1;
    // 如果事件处理时间很短，则在中断里面处理
    // 如果事件处理时间比较长，在回到前台处理
    DoSomething1();
}
```

在顺序执行后台程序的时候，如果有中断来临，那么中断会打断后台程序的正常执行流，转而去执行中断服务程序，在中断服务程序里面标记事件，如果事件要处理的事情很简短，则可在中断服务程序里面处理，如果事件要处理的事情比较多，则返回到后台程序里面处理。虽然事件的响应和处理是分开了，但是事件的处理还是在后台里面顺序执行的，但相比轮询系统，前后台系统确保了事件不会丢失，再加上中断具有可嵌套的功能，这可以大大的提高程序的实时响应能力。在大多数的中小型项目中，前后台系统运用的好，堪称有操作系统的效果。

## 2. 多任务系统

相比前后台系统，多任务系统的事件响应也是在中断中完成的，但是事件的处理是在任务中完成的。在多任务系统中， 任务跟中断一样，也具有优先级，优先级高的任务会被优先执行。当一个紧急的事件在中断被标记之后，如果事件对应的任务的优先级足够高，就会立马得到响应。相比前后台系统，多任务系统的实时性又被提高了。

```c
#include <stm32f4xx.h>

int flag1 = 0;
int flag2 = 0;
int flag3 = 0;

int main(void)
{
    // 硬件相关初始化
    HardwareInit();
    // OS初始化
    RTOSInit();
    // OS启动，开启多任务调度
    RTOSStart();
}

void ISR1(void)
{
    // 置位flag1
    flag1 = 1;
}

void ISR2(void)
{
    // 置位flag2
    flag2 = 1;
}

void ISR3(void)
{
    // 置位flag3
    flag3 = 1;
}

void Dosomething(void)
{
    // 无限循环，不能返回
    for(;;)
    {
        if(flag1)
        {
            // 处理flag1
        }
    }
}
```

相比前后台系统中后台顺序执行的程序主体，在多任务系统中，根据程序的功能，我们把这个程序主体分割成一个个独立的，无限循环且不能返回的小程序，这个小程序我们称之为任务。每个任务都是独立的，互不干扰的，且具备自身的优先级，它由操作系统调度管理。加入操作系统后，我们在编程的时候不需要精心地去设计程序的执行流，不用担心每个功能模块之间是否存在干扰。加入了操作系统，我们的编程反而变得简单了。整个系统随之带来的额外开销就是操作系统占据的那一丁点的 FLASH 和 RAM。现如今，单片机的 FLASH 和 RAM 是越来越大，完全足以抵挡 RTOS 那点开销。


