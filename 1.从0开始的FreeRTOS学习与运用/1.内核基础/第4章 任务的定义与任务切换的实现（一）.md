# 第四章 任务的定义与任务切换的实现（一）

## 1. 本章目标

在这章中， 我们会创建两个任务，并让这两个任务不断地切换， 任务的主体都是让一个变量按照一定的频率翻转，通过 KEIL 的软件仿真功能，在逻辑分析仪中观察变量的波形变化，最终的波形图具体见图：

![屏幕截图 2024 10 05 105108](https://img.picgo.net/2024/10/05/-2024-10-05-1051080c676335a415d598.png)

其实， 上图的波形图的效果，并不是真正的多任务系统中任务切换的效果图，这个效果其实可以完全由裸机代码来实现

```c
uint32_t flag1;
uint32_t flag2;
// 软件延时，不必纠结具体的时间 
void delay( uint32_t count )
{
    for (; count!=0; count--);
}

int main()
{
    while(1)
    {
        flag1 = 1;
        delay(100);
        flag1 = 0;
        delay(100);

        flag2 = 1;
        delay(100);    
        flag2 = 0;
        delay(100); 
    }
}
```

在多任务系统中，两个任务不断切换的效果图应该像下图图所示那样，即两个变量的波形是完全一样的，就好像 CPU 在同时干两件事一样，这才是多任务的意义。虽然两者的波形图一样，但是，代码的实现方式是完全不一样的，由原来的顺序执行变成了任务的主动切换，这是根本区别。

这章只是开始，我们先掌握好任务是如何切换，在后面章节中，我们会陆续的完善功能代码，加入系统调度，实现真正的多任务。

![屏幕截图 2024 10 05 105207](https://img.picgo.net/2024/10/05/-2024-10-05-10520772faa131136bcb64.png)

## 2. 什么是任务

在裸机系统中， 系统的主体就是 main 函数里面顺序执行的无限循环，这个无限循环里面 CPU 按照顺序完成各种事情。在多任务系统中，我们根据功能的不同，把整个系统分割成一个个独立的且无法返回的函数，这个函数我们称为任务。 任务的大概形式具体见代码

```c
void task_entry(void *parg)
{
    // 任务主体，无限循环且不能返回
    while(1)
    {
        // 任务主体代码
    }
}
```

## 3. 创建任务

### 3.1 定义任务栈

我们先回想下，在一个裸机系统中， 如果有全局变量，有子函数调用，有中断发生。那么系统在运行的时候，全局变量放在哪里，子函数调用时，局部变量放在哪里， 中断发生时，函数返回地址放哪里。

如果只是单纯的裸机编程，它们放哪里我们不用管，但是如果要写一个 RTOS，这些种种环境参数，我们必须弄清楚他们是如何存储的。在裸机系统中，他们统统放在一个叫栈的地方，栈是单片机 RAM 里面一段连续的内存空间，栈的大小一般在启动文件或者链接脚本里面指定， 最后由 C 库函数_main 进行初始化。

但是， 在多任务系统中，每个任务都是独立的，互不干扰的，所以要为每个任务都分配独立的栈空间，这个栈空间通常是一个预先定义好的全局数组， 也可以是动态分配的一段内存空间，但它们都存在于 RAM 中。

本章我们要实现两个变量按照一定的频率轮流的翻转，每个变量对应一个任务，那么就需要定义两个任务栈，在多任务系统中，有多少个任务就需要定义多少个任务栈。

```c
#define TASK1_STACK_SIZE 128 
StackType_t Task1Stack[TASK1_STACK_SIZE];

#define TASK2_STACK_SIZE 128
StackType_t Task2Stack[TASK2_STACK_SIZE];
```

任务栈其实就是一个预先定义好的全局数据，数据类型为StackType_t，大小由 TASK1_STACK_SIZE 这个宏来定义， 默认为 128，单位为字，即 512字节，这也是 FreeRTOS 推荐的最小的任务栈。在 FreeRTOS 中，凡是涉及到数据类型的地方， FreeRTOS 都会将标准的 C 数据类型用 typedef 重新取一个类型名。这些经过重定义的数据类型放在 portmacro.h

```c
#define portSTACK_TYPE uint32_t

typedef portSTACK_TYPE StackType_t;
// uint32_t = StackType_t
```

### 3.2 定义任务函数

任务是一个独立的函数，函数主体无限循环且不能返回。本章我们在 main.c 中定义的两个任务具体见代码

```c
// 软件延时，不必纠结具体的时间 
void delay( uint32_t count )
{
    for (; count!=0; count--);
}

// 任务1
void Task1_Entry(void *p_arg)
{
    while(1)
    {
        flag1 = 1;
        delay(100);
        flag1 = 0;
        delay(100);
    }
}   
void Task2_Entry(void *p_arg)
{ 
    while(1)
    {
        flag2 = 1;
        delay(100);    
        flag2 = 0;
        delay(100); 
    }
}
```

正如我们所说的那样， 任务是一个独立的、无限循环且不能返回的函数。

### 3.3 定义任务控制块

在裸机系统中，程序的主体是 CPU 按照顺序执行的。而在多任务系统中， 任务的执行是由系统调度的。

系统为了顺利的调度任务，为每个任务都额外定义了一个任务控制块，这个任务控制块就相当于任务的身份证，里面存有任务的所有信息，比如任务的栈指针，任务名称， 任务的形参等。有了这个任务控制块之后，以后系统对任务的全部操作都可以通过这个任务控制块来实现。 

定义一个任务控制块需要一个新的数据类型， 该数据类型在task.c 这 C 头文件中声明（为了 tskTCB 这个数据类型能在其它地方使用，讲解的时候我把这个任务控制块的声明放在了 FreeRTOS.h 这个头文件）使用它可以为每个任务都定义一个任务控制块实体。

```c
typedef struct tskTaskControlBlock
{
    volatile StackType_t *pxTopOfStack; // 栈顶 
    ListItem_t xStateListItem; // 任务节点 

    StackType_t *pxStack; // 任务栈起始地址 
    // 任务名称，字符串形式 
    char pcTaskName[configMAX_TASK_NAME_LEN];
}tskTCB;
```

有关代码详细解释如下：

- 栈顶指针，作为 TCB 的第一个成员。

- 任务节点，这是一个内置在 TCB 控制块中的链表节点，通过这个节点，可以将任务控制块挂接到各种链表中。这个节点就类似晾衣架的钩子， TCB 就是衣服。

- 任务栈起始地址

- 任务名称，字符串形式， 长度由宏 configMAX_TASK_NAME_LEN 来控制， 该宏在 FreeRTOSConfig.h 中定义，默认为 16。

- 数据类型重定义

在本章实验中，我们在 main.c 文件中为两个任务定义的任务控制块， 具体见代码

```c
// 定义任务控制块
TCB_t Task1TCB;
TCB_t Task2TCB;
```

### 3.4 实现任务创建函数

任务的栈， 任务的函数实体， 任务的控制块最终需要联系起来才能由系统进行统一调度。那么这个联系的工作就由任务创建函数 xTaskCreateStatic()来实现，该函数在 task.c中定义， 在 task.h 中声明， 所有跟任务相关的函数都在这个文件定义。

#### 3.4.1 xTaskCreateStatic()函数

```c
#if(configSUPPORT_STATIC_ALLOCATION == 1)

TaskHandle_t xTaskCreateStatic(TaskFunction_t pxTaskCode, // 任务入口
                                const char *const pcName, // 任务名称，字符串形式
                                const uint32_t ulStackDepth, // 任务栈大小
                                void *const pvParameters, // 任务形参
                                StackType_t *const puxStackBuffer, // 任务栈起始地址
                                TCB_t *const pxTaskBuffer) // 任务控制块指针
{
    TCB_t *pxNewTCB;
    TaskHandle_t xReturn; // 定义一个任务句柄 xReturn， 任务句柄用于指向任务的 TCB

    if((pxTaskBuffer != NULL) && (puxStackBuffer != NULL))
    {
        pxNewTCB = (TCB_t*)pxTaskBuffer;
        pxNewTCB->pxStack = (StackType_t*)puxStackBuffer;

        // 调用 prvInitialiseNewTask()函数，创建新的任务 
        prvInitialiseNewTask(pxTaskCode, // 任务入口 
                            pcName, // 任务名称，字符串形式 
                            ulStackDepth, // 任务栈大小，单位为字 
                            pvParameters, // 任务形参 
                            &xReturn, // 任务句柄 
                            pxNewTCB); // 任务栈起始地址 
    }
    else
    {
        xReturn = NULL;
    }
    // 返回任务句柄，如果任务创建成功，此时 xReturn 应该指向任务控制块 
        return xReturn; 
}
#endif /* configSUPPORT_STATIC_ALLOCATION */
```

- FreeRTOS 中，任务的创建有两种方法，一种是使用动态创建，一种是使用静态创建。 动态创建时，任务控制块和栈的内存是创建任务时动态分配的， 任务删除时，内存可以释放。 静态创建时，任务控制块和栈的内存需要事先定义好，是静态的内存，任务删除时，内存不能释放。目前我们以静态创建为例来讲解，configSUPPORT_STATIC_ALLOCATION 在 FreeRTOSConfig.h 中定义，我们配置为 1。

- 任务入口，即任务的函数名称。 TaskFunction_t 是在 projdefs.h中重定义的一个数据类型，实际就是空指针

```c
#ifndef PROJDEFS_H
#define PROJDEFS_H

typedef void (*TaskFunction_t)(void*);

#define pdFALSE ((BaseType_t)0)
#define pdTRUE ((BaseType_t) 1)

#define pdPASS (pdTRUE)
#define pdFAIL (pdFALSE)

#endif /* PROJDEFS_H */
```

#### 3.4.2 prvInitialiseNewTask()函数

```c
static void prvInitialiseNewTask(TaskFunction_t pxTaskCode,   // 任务入口
                            const char* const pcName,         // 任务名称
                            const uint32_t ulStackDepth,      // 任务栈大小
                            void* const pvParameters,         // 任务形参
                            TaskHandle_t* const pxCreatedTask,// 任务句柄
                            TCB_t *pxNewTCB) // 任务控制块指针
{
    StackType_t *pxTopOfStack;
    UBaseType_t x;

    // 获取栈顶地址 
    pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
    // 向下做 8 字节对齐 
    pxTopOfStack = (StackType_t*) \
    (((uint32_t)pxTopOfStack) & (~((uint32_t)0x0007)));

    // 将任务的名字存储在 TCB 中     
    for(x=(UBaseType_t)0; x<(UBaseType_t)configMAX_TASK_NAME_LEN; x++ )
    {
        pxNewTCB->pcTaskName[x] = pcName[x];
        if(pcName[x] == 0x00)
        {
            break;
        }
}    
    // 任务名字的长度不能超过 configMAX_TASK_NAME_LEN 
    pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN-1] = '\0';
    // 初始化 TCB 中的 xStateListItem 节点 
    vListInitialiseItem(&(pxNewTCB->xStateListItem));    
    // 设置 xStateListItem 节点的拥有者 
    listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem ), pxNewTCB);
    // 初始化任务栈 
    pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack,
                                                    pxTaskCode,
                                                    pvParameters);
    // 让任务句柄指向任务控制块 
    if((void*) pxCreatedTask != NULL)
    {
        *pxCreatedTask = (TaskHandle_t)pxNewTCB;
    }
}
```

- 将栈顶指针向下做 8 字节对齐。 在 Cortex-M3（Cortex-M4 或Cortex-M7）内核的单片机中，因为总线宽度是 32 位的，通常只要栈保持 4 字节对齐就行，可这样为啥要 8 字节？难道有哪些操作是 64 位的？确实有，那就是浮点运算，所以要 8 字节对齐（但是目前我们都还没有涉及到浮点运算，只是为了后续兼容浮点运行的考虑）。如果栈顶指针是 8 字节对齐的，在进行向下 8 字节对齐的时候，指针不会移动，如果不是8 字节对齐的，在做向下 8 字节对齐的时候，就会空出几个字节，不会使用，比如当pxTopOfStack 是 33，明显不能整除 8，进行向下 8 字节对齐就是 32，那么就会空出一个字节不使用。

- 调用 pxPortInitialiseStack()函数初始化任务栈， 并更新栈顶指针，任务第一次运行的环境参数就存在任务栈中。该函数在 port.c中定义。任务栈初始化完毕之后，栈空间内部分布图具体见图

![屏幕截图 2024 10 05 154038](https://img.picgo.net/2024/10/05/-2024-10-05-1540386db5d60bbec29b39.png)

#### 3.4.3 pxPortInitialiseStack()函数

```c
#define portINITIAL_XPSR (0x01000000)
#define portSTART_ADDRESS_MASK ((StackType_t)0xfffffffeUL)

static void prvTaskExitError(void)
{
    // 函数停止在这里
    for(;;);
}
StackType_t *pxPortInitialiseStack(StackType_t *pxTopOfStack,
                                    TaskFunction_t pxCode,
                                    void *pvParameters)
{
// 异常发生时， CPU 自动从栈中加载到 CPU 寄存器的内容。包括 8
// 个寄存器，分别为 R0、 R1、 R2、 R3、 R12、 R14、 R15 和 xPSR 的位 24，且顺序不能变。
    // 异常发生时，自动加载到 CPU 寄存器的内容 
    pxTopOfStack--;
    *pxTopOfStack = portINITIAL_XPSR; // xPSR 的 bit24 必须置 1，即 0x01000000
    pxTopOfStack--;
    *pxTopOfStack = ((StackType_t)pxCode) &portSTART_ADDRESS_MASK; // 任务的入口地址
    pxTopOfStack--;
    *pxTopOfStack = (StackType_t)prvTaskExitError; // 任务的返回地址，通常任务是不会返回的，如果返回了就跳转到     
                                                   // prvTaskExitError， 该函数是一个无限循环
    pxTopOfStack -= 5; // R12, R3, R2 and R1 默认初始化为 0 
    *pxTopOfStack = (StackType_t)pvParameters;
    // 异常发生时，手动加载到 CPU 寄存器的内容 
    pxTopOfStack -= 8;
    // 返回栈顶指针，此时 pxTopOfStack 指向空闲栈 
    return pxTopOfStack; // 返回栈顶指针
}
```

- 返回栈顶指针，此时 pxTopOfStack 指向具体见图。任务第一次运行时，就是从这个栈指针开始手动加载 8 个字的内容到 CPU 寄存器： R4、 R5、 R6、 R7、R8、 R9、 R10 和 R11，当退出异常时，栈中剩下的 8 个字的内容会自动加载到 CPU 寄存器： R0、 R1、 R2、 R3、 R12、 R14、 R15 和 xPSR 的位 24。此时 PC 指针就指向了任务入口地址，从而成功跳转到第一个任务。
