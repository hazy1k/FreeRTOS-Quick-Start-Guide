# 第十二章 任务通知

## 1. 任务通知的基本概念

FreeRTOS 从 V8.2.0 版本开始提供任务通知这个功能，每个任务都有一个 32 位的通知值，在大多数情况下，任务通知可以替代二值信号量、计数信号量、事件组， 也可以替代长度为 1 的队列（可以保存一个 32 位整数或指针值） 。

相对于以前使用 FreeRTOS 内核通信的资源，必须创建队列、二进制信号量、计数信号量或事件组的情况，使用任务通知显然更灵活。 按照 FreeRTOS 官方的说法，使用任务通知比通过信号量等 ICP 通信方式解除阻塞的任务要快 45%，并且更加省 RAM 内存空间（使用 GCC 编译器， -o2 优化级别） ，任务通知的使用无需创建队列。 想要使用任务通知，必须将 FreeRTOSConfig.h 中的宏定义 configUSE_TASK_NOTIFICATIONS 设置为 1，其实FreeRTOS 默认是为 1 的， 所以任务通知是默认使能的。

FreeRTOS 提供以下几种方式发送通知给任务 ：

- 发送通知给任务。如果有通知未读，不覆盖通知值

- 发送通知给任务。直接覆盖通知值

- 发送通知给任务，设置通知值的一个或者多个位，可用当作事件组来使用

- 发送通知给任务，递增通知值，可用当做计数量信号量使用

通过对以上任务通知方式的合理使用，可以在一定场合下替代 FreeRTOS 的信号量，队列、事件组等。

当然， 凡是都有利弊，不然的话 FreeRTOS 还要内核的 IPC 通信机制干嘛， 消息通知虽然处理更快， RAM 开销更小，但也有以下限制 ：

- 只能有一个任务介绍通知消息，因为必须指定接收通知的任务

- 只有等待通知的任务可以被阻塞，发送通知的任务，在任何情况下都不会因为发送失败而进入阻塞态

## 2. 任务通知的运作机制

顾名思义，任务通知是属于任务中附带的资源， 所以在任务被创建的时候，任务通知也被初始化的， 而在分析队列和信号量的章节中，我们知道在使用队列、信号量前，必须先创建队列和信号量，目的是为了创建队列数据结构。比如使用 xQueueCreate()函数创建队列，用 xSemaphoreCreateBinary()函数创建二值信号量等等。再来看任务通知，由于任务通知的数据结构包含在任务控制块中，只要任务存在，任务通知数据结构就已经创建完毕，可以直接使用， 所以使用的时候很是方便。

任务通知可以在任务中向指定任务发送通知，也可以在中断中向指定任务发送通知， FreeRTOS 的每个任务都有一个 32 位的通知值，任务控制块中的成员变量 ulNotifiedValue就是这个通知值。只有在任务中可以等待通知，而不允许在中断中等待通知。如果任务在等待的通知暂时无效，任务会根据用户指定的阻塞超时时间进入阻塞状态，我们可以将等待通知的任务看作是消费者；其它任务和中断可以向等待通知的任务发送通知，发送通知的任务和中断服务函数可以看作是生产者，当其他任务或者中断向这个任务发送任务通知，任务获得通知以后，该任务就会从阻塞态中解除，这与 FreeRTOS 中内核的其他通信机制一致。

## 3. 任务通知实验

### 3.1 任务通知代替消息队列

任务通知代替消息队列是在 FreeRTOS 中创建了三个任务， 其中两个任务是用于接收任务通知，另一个任务发送任务通知。三个任务独立运行，发送消息任务是通过检测按键的按下情况来发送消息通知，另两个任务获取消息通知，在任务通知中没有可用的通知之前就一直等待消息，一旦获取到消息通知就把消息打印在串口调试助手里

```c
/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
/* 其他头文件 */
#include "uart.h"
#include "led.h"
#include "key.h"
#include "limits.h"

/* 任务句柄 */
static TaskHandle_t AppTaskCreate_Handle = NULL; // 创建任务句柄

static TaskHandle_t Receive1_Task_Handle = NULL; // 接收任务1句柄
static TaskHandle_t Receive2_Task_Handle = NULL; // 接收任务2句柄
static TaskHandle_t Send_Task_Handle = NULL; // 发送任务句柄

/* 内核对象句柄 */
/* 全局变量声明 */
/* 宏定义 */
#define USE_CHAR 0 // 测试字符串的时候配置为1 测试变量的时候配置为0

/* 任务函数声明 */
static void AppTaskCreate(void); // 创建任务函数

static void Receive1_Task(void* pvParameters); // 接收任务1函数
static void Receive2_Task(void* pvParameters); // 接收任务2函数
static void Send_Task(void* pvParameters); // 发送任务函数

static void BSP_Init(void); // 板级初始化函数

// 主函数启动流程
/*
    1.BSP初始化
    2.创建APP任务
    3.启动FreeRTOS,开启调度
*/
int main(void)
{
    BaseType_t xReturn = pdPASS; // 定义一个创建信息返回值，默认为pdPASS
    BSP_Init(); // 板级初始化
    printf("这是一个FreeRTOS任务通知代替消息队列的测试程序\r\n");
    printf("按下KEY1或者KEY2向任务发送消息通知\r\n");
    // 创建AppTaskCreate任务   
    xReturn = xTaskCreate((TaskFunction_t )AppTaskCreate,
                        (const char*)"AppTaskCreate",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)1, 
                        (TaskHandle_t*)&AppTaskCreate_Handle); 
    if(xReturn == pdPASS)
    {
        vTaskStartScheduler(); // 启动FreeRTOS
    }
    else
    {
        return -1;
    }
    while(1);
}

// 为了方便管理，所有任务创建函数都在AppTaskCreate中实现
static void AppTaskCreate(void)
{
  BaseType_t xReturn = pdPASS;
  taskENTER_CRITICAL(); // 进入临界区

  xReturn = xTaskCreate((TaskFunction_t )Receive1_Task,
                        (const char*)"Receive1_Task",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)2,
                        (TaskHandle_t*)&Receive1_Task_Handle); 
  if(xReturn == pdPASS)
  {
    printf("创建接收任务1成功\r\n");
  }
  xReturn = xTaskCreate((TaskFunction_t )Receive2_Task,
                        (const char*)"Receive2_Task",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)3,
                        (TaskHandle_t*)&Receive2_Task_Handle); 
  if(xReturn == pdPASS)
  {
    printf("创建接收任务2成功\r\n");
  }
  xReturn = xTaskCreate((TaskFunction_t )Send_Task,
                        (const char*)"Send_Task",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)4,
                        (TaskHandle_t*)&Send_Task_Handle); 
  if(xReturn == pdPASS)
  {
    printf("创建发送任务成功\r\n");
  }

  vTaskDelete(AppTaskCreate_Handle);
  taskEXIT_CRITICAL(); // 退出临界区
}

// 接收任务1函数
static void Receive1_Task(void* pvParameters)
{
  BaseType_t xReturn = pdTRUE;
#if USE_CHAR
  char *r_char;
#else
  uint32_t r_num;
#endif
  while(1)
  {
    //获取任务通知 ,没获取到则一直等待
    xReturn = xTaskNotifyWait(0x0,     // 进入函数的时候不清除任务 bit
                              ULONG_MAX, // 退出函数的时候清除所有的 bit 
    #if USE_CHAR
                              (uint32_t *)&r_char, // 保存任务通知值
    #else
                              &r_num, // 保存任务通知值
    #endif
                              portMAX_DELAY); // 阻塞时间
    if(xReturn == pdTRUE)
    {
    #if USE_CHAR
      printf("Receive1_Task 任务通知为 %s \n",r_char);
    #else
      printf("Receive1_Task 任务通知为 %d \n",r_num);
    #endif
    }
    LED1_TOGGLE(); 
  }
}

// 接收任务2函数
static void Receive2_Task(void* pvParameters)
{
  BaseType_t xReturn = pdTRUE;
#if USE_CHAR
  char *r_char;
#else
  uint32_t r_num;
#endif
  while(1)
  {
    //获取任务通知 ,没获取到则一直等待
    xReturn = xTaskNotifyWait(0x0,     // 进入函数的时候不清除任务 bit
                              ULONG_MAX, // 退出函数的时候清除所有的 bit 
    #if USE_CHAR
                              (uint32_t *)&r_char, // 保存任务通知值
    #else
                              &r_num, // 保存任务通知值
    #endif
                              portMAX_DELAY); // 阻塞时间
    if(xReturn == pdTRUE)
    {
    #if USE_CHAR
      printf("Receive2_Task 任务通知为 %s \n",r_char);
    #else
      printf("Receive2_Task 任务通知为 %d \n",r_num);
    #endif
    }
    LED2_TOGGLE(); 
  }
}

// 发送任务函数
static void Send_Task(void* pvParameters)
{
  BaseType_t xReturn = pdPASS;
#if USE_CHAR
  char test_str1[] = "This is a test 1";
  char test_str2[] = "This is a test 2";
#else
  uint32_t test_num1 = 100;
  uint32_t test_num2 = 200;
#endif
  while(1)
  {
    /* KEY1被按下，向接收任务1发送通知 */
    if(Key_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == KEY_ON)
    {
      xReturn = xTaskNotify(Receive1_Task_Handle, // 通知接收任务1
      #if USE_CHAR
                            (uint32_t)&test_str1, // 通知值
      #else
                            test_num1, // 通知值
      #endif 
                            eSetValueWithOverwrite); // 覆盖当前通知
      if(xReturn == pdPASS)
      {
        printf("Receive1_Task 任务通知释放成功!\r\n");
      }                     
    }
    /* KEY2被按下，向接收任务2发送通知 */
    if(Key_Scan(KEY2_GPIO_PORT, KEY2_GPIO_PIN) == KEY_ON)
    {
      xReturn = xTaskNotify(Receive2_Task_Handle, // 通知接收任务2
      #if USE_CHAR
                            (uint32_t)&test_str2, // 通知值
      #else
                            test_num2, // 通知值
      #endif 
                            eSetValueWithOverwrite); // 覆盖当前通知
      if(xReturn == pdPASS)
      {
        printf("Receive2_Task 任务通知释放成功!\r\n");
      }
    }
    vTaskDelay(20);
  }
}

// 板级初始化函数
static void BSP_Init(void)
{
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); // 设置中断优先级分组4
    LED_Init();
    USART_Config();
    Key_GPIO_Config();
}
```

### 3.2 任务通知替代二值信号量

任务通知代替消息队列是在 FreeRTOS 中创建了三个任务，其中两个任务是用于接收任务通知，另一个任务发送任务通知。三个任务独立运行，发送通知任务是通过检测按键的按下情况来发送通知，另两个任务获取通知，在任务通知中没有可用的通知之前就一直等待任务通知，获取到通知以后就将通知值清 0，这样子是为了代替二值信号量，任务同步成功则继续执行，然后在串口调试助手里将运行信息打印出来

```c
/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
/* 其他头文件 */
#include "uart.h"
#include "led.h"
#include "key.h"

/* 任务句柄 */
static TaskHandle_t AppTaskCreate_Handle = NULL; // 创建任务句柄

static TaskHandle_t Receive1_Task_Handle = NULL; // 接收任务1句柄
static TaskHandle_t Receive2_Task_Handle = NULL; // 接收任务2句柄
static TaskHandle_t Send_Task_Handle = NULL; // 发送任务句柄

/* 内核对象句柄 */
/* 全局变量声明 */
/* 宏定义 */

/* 任务函数声明 */
static void AppTaskCreate(void); // 创建任务函数

static void Receive1_Task(void* pvParameters); // 接收任务1函数
static void Receive2_Task(void* pvParameters); // 接收任务2函数
static void Send_Task(void* pvParameters); // 发送任务函数

static void BSP_Init(void); // 板级初始化函数

// 主函数启动流程
/*
    1.BSP初始化
    2.创建APP任务
    3.启动FreeRTOS,开启调度
*/
int main(void)
{
    BaseType_t xReturn = pdPASS; // 定义一个创建信息返回值，默认为pdPASS
    BSP_Init(); // 板级初始化
    printf("这是一个FreeRTOS任务通知代替二值信号量的测试程序\r\n");
    printf("按下KEY1或者KEY2键进行任务与任务之间的同步\r\n");
    // 创建AppTaskCreate任务   
    xReturn = xTaskCreate((TaskFunction_t )AppTaskCreate,
                        (const char*)"AppTaskCreate",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)1, 
                        (TaskHandle_t*)&AppTaskCreate_Handle); 
    if(xReturn == pdPASS)
    {
        vTaskStartScheduler(); // 启动FreeRTOS
    }
    else
    {
        return -1;
    }
    while(1);
}

// 为了方便管理，所有任务创建函数都在AppTaskCreate中实现
static void AppTaskCreate(void)
{
  BaseType_t xReturn = pdPASS;
  taskENTER_CRITICAL(); // 进入临界区

  xReturn = xTaskCreate((TaskFunction_t )Receive1_Task,
                        (const char*)"Receive1_Task",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)2,
                        (TaskHandle_t*)&Receive1_Task_Handle); 
  if(xReturn == pdPASS)
  {
    printf("创建接收任务1成功\r\n");
  }
  xReturn = xTaskCreate((TaskFunction_t )Receive2_Task,
                        (const char*)"Receive2_Task",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)3,
                        (TaskHandle_t*)&Receive2_Task_Handle); 
  if(xReturn == pdPASS)
  {
    printf("创建接收任务2成功\r\n");
  }
  xReturn = xTaskCreate((TaskFunction_t )Send_Task,
                        (const char*)"Send_Task",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)4,
                        (TaskHandle_t*)&Send_Task_Handle); 
  if(xReturn == pdPASS)
  {
    printf("创建发送任务成功\r\n");
  }

  vTaskDelete(AppTaskCreate_Handle);
  taskEXIT_CRITICAL(); // 退出临界区
}

// 接收任务1函数
static void Receive1_Task(void* pvParameters)
{
  while(1)
  {
    ulTaskNotifyTake(pdTRUE, portMAX_DELAY); // 等待通知
    printf("接收任务1收到通知\r\n");
    LED1_TOGGLE();
  }
}

// 接收任务2函数
static void Receive2_Task(void* pvParameters)
{
  while(1)
  {
    ulTaskNotifyTake(pdTRUE, portMAX_DELAY); // 等待通知
    printf("接收任务2收到通知\r\n");
    LED2_TOGGLE();
  }
}

static void Send_Task(void* pvParameters)
{
  BaseType_t xReturn = pdPASS;
  while(1)
  {
    if(Key_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == KEY_ON)
    {
      xReturn = xTaskNotifyGive(Receive1_Task_Handle); // 发送通知给接收任务1
      if(xReturn == pdPASS)
      {
        printf("发送任务给接收任务1成功\r\n");
      }
    }
    if(Key_Scan(KEY2_GPIO_PORT, KEY2_GPIO_PIN) == KEY_ON)
    {
      xReturn = xTaskNotifyGive(Receive2_Task_Handle); // 发送通知给接收任务2
      if(xReturn == pdPASS)
      {
        printf("发送任务给接收任务2成功\r\n");
      }
    }
    vTaskDelay(20);
  }
}

// 板级初始化函数
static void BSP_Init(void)
{
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); // 设置中断优先级分组4
    LED_Init();
    USART_Config();
    Key_GPIO_Config();
}
```

### 3.3 任务通知代替计数信号量

任务通知代替计数信号量是基于计数型信号量实验修改而来，模拟停车场工作运行。并且在 FreeRTOS 中创建了两个任务：一个是获取任务通知，一个是发送任务通知，两个任务独立运行，获取通知的任务是通过按下 KEY1 按键获取，模拟停车场停车操作，其等待时间是 0；发送通知的任务则是通过检测 KEY2 按键按下进行通知的发送，模拟停车场取车操作，并且在串口调试助手输出相应信息

```c
/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"
/* 其他头文件 */
#include "uart.h"
#include "led.h"
#include "key.h"

/* 任务句柄 */
static TaskHandle_t AppTaskCreate_Handle = NULL; // 创建任务句柄

static TaskHandle_t Take_Task_Handle = NULL;
static TaskHandle_t Give_Task_Handle = NULL;

/* 内核对象句柄 */
SemaphoreHandle_t CountSem_Handle = NULL;
/* 全局变量声明 */
/* 宏定义 */

/* 任务函数声明 */
static void AppTaskCreate(void); // 创建任务函数

static void Take_Task(void* pvParameters);
static void Give_Task(void* pvParameters);

static void BSP_Init(void); // 板级初始化函数

// 主函数启动流程
/*
    1.BSP初始化
    2.创建APP任务
    3.启动FreeRTOS,开启调度
*/
int main(void)
{
    BaseType_t xReturn = pdPASS; // 定义一个创建信息返回值，默认为pdPASS
    BSP_Init(); // 板级初始化
    printf("这一个FreeRTOS任务通知代替计数信号量的例子\r\n");
    printf("车位默认10个，按下KEY1申请车位，按下KEY2释放车位\r\n");
    // 创建AppTaskCreate任务   
    xReturn = xTaskCreate((TaskFunction_t )AppTaskCreate,
                        (const char*)"AppTaskCreate",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)1, 
                        (TaskHandle_t*)&AppTaskCreate_Handle); 
    if(xReturn == pdPASS)
    {
        vTaskStartScheduler(); // 启动FreeRTOS
    }
    else
    {
        return -1;
    }
    while(1);
}

// 为了方便管理，所有任务创建函数都在AppTaskCreate中实现
static void AppTaskCreate(void)
{
  BaseType_t xReturn = pdPASS;
  taskENTER_CRITICAL(); // 进入临界区

  xReturn = xTaskCreate((TaskFunction_t )Take_Task,
                        (const char*)"Take_Task",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)2,
                        (TaskHandle_t*)&Take_Task_Handle);
  if(xReturn == pdPASS)
  {
    printf("创建Take_Task成功\r\n");
  }
  xReturn = xTaskCreate((TaskFunction_t )Give_Task,
                        (const char*)"Give_Task",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)3,
                        (TaskHandle_t*)&Give_Task_Handle);
  if(xReturn == pdPASS)
  {
    printf("创建Give_Task成功\r\n");
  }

  vTaskDelete(AppTaskCreate_Handle);
  taskEXIT_CRITICAL(); // 退出临界区
}

// Taske_Task函数，申请车位
static void Take_Task(void* pvParameters)
{
  uint32_t take_num = pdTRUE;
  while(1)
  {
    if(Key_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == KEY_ON)
    {
      // 获取任务通知，没获取到则不等待
      take_num = ulTaskNotifyTake(pdFALSE, 0);
      if(take_num > 0)
      {
        printf("KEY1被按下，成功申请到车位。当前车位为 %d\r\n", take_num-1);
      }
      else
      {
        printf("KEY1被按下，但没有车位可用。\r\n");
      }
    }
    vTaskDelay(20);
  }
}

static void Give_Task(void* pvParameters)
{
  BaseType_t xReturn = pdPASS;
  while(1)
  {
    if(Key_Scan(KEY2_GPIO_PORT, KEY2_GPIO_PIN) == KEY_ON)
    {
      xTaskNotifyGive(Take_Task_Handle); // 通知Take_Task任务，有车位可用
      if(xReturn == pdPASS)
      {
        printf("KEY2被按下，成功释放车位。\r\n");
      }
    }
    vTaskDelay(20);
  }
}

// 板级初始化函数
static void BSP_Init(void)
{
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); // 设置中断优先级分组4
    LED_Init();
    USART_Config();
    Key_GPIO_Config();
}
```

### 3.4 任务通知代替事件组

任务通知代替事件组实验是在事件标志组实验基础上进行修改，实验任务通知替代事件实现事件类型的通信，该实验是在 FreeRTOS 中创建了两个任务，一个是发送事件通知任务，一个是等待事件通知任务，两个任务独立运行， 发送事件通知任务通过检测按键的按下情况设置不同的通知值位，等待事件通知任务则获取这任务通知值，并且根据通知值判断两个事件是否都发生，如果是则输出相应信息， LED 进行翻转。 等待事件通知任务的等待时间是 portMAX_DELAY，一直在等待事件通知的发生， 等待获取到事件之后清除对应的任务通知值的位

```c
/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "event_groups.h"
/* 其他头文件 */
#include "uart.h"
#include "led.h"
#include "key.h"
#include "limits.h"

/* 任务句柄 */
static TaskHandle_t AppTaskCreate_Handle = NULL; // 创建任务句柄

static TaskHandle_t LED_Task_Handle = NULL; // LED任务句柄
static TaskHandle_t KEY_Task_Handle = NULL; // 按键任务句柄

/* 内核对象句柄 */
static EventGroupHandle_t Event_Handle = NULL;
/* 全局变量声明 */
/* 宏定义 */
#define KEY1_EVENT (0x01 << 0) // 设置事件掩码的位0
#define KEY2_EVENT (0x01 << 1) // 设置事件掩码的位1

/* 任务函数声明 */
static void AppTaskCreate(void); // 创建任务函数

static void LED_Task(void* pvParameters);
static void KEY_Task(void* pvParameters);

static void BSP_Init(void); // 板级初始化函数

// 主函数启动流程
/*
    1.BSP初始化
    2.创建APP任务
    3.启动FreeRTOS,开启调度
*/
int main(void)
{
    BaseType_t xReturn = pdPASS; // 定义一个创建信息返回值，默认为pdPASS
    BSP_Init(); // 板级初始化
    printf("这是一个FreeRTOS优先级翻转实验。\r\n");
    printf("按下KEY1或者KEY2发送事件任务通知。\r\n");
    // 创建AppTaskCreate任务   
    xReturn = xTaskCreate((TaskFunction_t )AppTaskCreate,
                        (const char*)"AppTaskCreate",
                        (uint16_t)512,  
                        (void*)NULL,
                        (UBaseType_t)1, 
                        (TaskHandle_t*)&AppTaskCreate_Handle); 
    if(xReturn == pdPASS)
    {
        vTaskStartScheduler(); // 启动FreeRTOS
    }
    else
    {
        return -1;
    }
    while(1);
}

// 为了方便管理，所有任务创建函数都在AppTaskCreate中实现
static void AppTaskCreate(void)
{
  BaseType_t xReturn = pdPASS;
  taskENTER_CRITICAL(); // 进入临界区

  Event_Handle = xEventGroupCreate(); // 创建事件组
  if(Event_Handle != NULL)
  {
    printf("事件组创建成功。\r\n");
  }
  xReturn = xTaskCreate((TaskFunction_t )LED_Task,
                        (const char*)"LED_Task",
                        (uint16_t)512,  
                        (void*)NULL,  
                        (UBaseType_t)2, 
                        (TaskHandle_t*)&LED_Task_Handle); // 创建LED任务
  if(xReturn == pdPASS)
  {
    printf("LED任务创建成功。\r\n");
  }
  xReturn = xTaskCreate((TaskFunction_t )KEY_Task,
                        (const char*)"KEY_Task",
                        (uint16_t)512,  
                        (void*)NULL,  
                        (UBaseType_t)3, 
                        (TaskHandle_t*)&KEY_Task_Handle); // 创建按键任务
  if(xReturn == pdPASS)
  {
    printf("按键任务创建成功。\r\n");
  }

  vTaskDelete(AppTaskCreate_Handle);
  taskEXIT_CRITICAL(); // 退出临界区
}

static void LED_Task(void* pvParameters)
{
  uint32_t r_event;
  uint32_t last_event = 0;
  BaseType_t xReturn = pdTRUE;
  while(1)
  {
    xReturn = xTaskNotifyWait(0x0, ULONG_MAX, &r_event, portMAX_DELAY); // 等待事件通知
    if(xReturn == pdTRUE)
    {
      last_event |= r_event; // 记录事件
      if(last_event == (KEY1_EVENT | KEY2_EVENT))
      {
        last_event = 0; // 清空事件
        printf("KEY1和KEY2同时按下，翻转LED。\r\n");
        LED1_TOGGLE(); // 翻转LED
      }
      else
      {
        last_event = r_event;
      }
    }
  }
}

static void KEY_Task(void* pvParameters)
{
  while(1)
  {
    if(Key_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == KEY_ON)
    {
      printf("KEY1按下。\r\n");
      xTaskNotify(LED_Task_Handle, (uint32_t)KEY1_EVENT, (eNotifyAction)eSetBits); // 发送KEY1事件通知
    }
    if(Key_Scan(KEY2_GPIO_PORT, KEY2_GPIO_PIN) == KEY_ON)
    {
      printf("KEY2按下。\r\n");
      xTaskNotify(LED_Task_Handle, (uint32_t)KEY2_EVENT, (eNotifyAction)eSetBits); // 发送KEY2事件通知
    }
    vTaskDelay(20);
  }
}

// 板级初始化函数
static void BSP_Init(void)
{
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); // 设置中断优先级分组4
    LED_Init();
    USART_Config();
    Key_GPIO_Config();
}
```
